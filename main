#pragma once

//------------------------
//        headers        |
//------------------------
// SDL
#include <SDL.h>
#include <SDL_ttf.h>
// Box2D
#include <Box2D.h>
//math
#include <cmath>
// vector string and I/O
#include <vector>
#include <unordered_map>
#include <string>
#include <iostream>
#include <fstream>
// random 
#include <random>
// time
#include <chrono>
// windows.h
#include <windows.h>
#pragma comment(lib, "Winmm.lib")

void emptyFunction() {

}

namespace ogf {
    // predefine functions
    float Angle_To(int p1x, int p1y, int p2x, int p2y);
    double Distance_To(int x, int y, int x1, int y1);
    double Distance_To(b2Vec2 p1, b2Vec2 p2);
    b2Vec2 AngleAndDistance_To(int x, int y, double angle, double distance);

    //------------------------
    //        colors         |
    //------------------------

    // Define commonly used colors
#define RED { 255, 0, 0, 255 }
#define GREEN { 0, 255, 0, 255 }
#define BLUE { 0, 0, 255, 255 }
#define BLACK { 0, 0, 0, 255 }
#define WHITE { 255, 255, 255, 255 }
#define YELLOW { 255, 255, 0, 255 }
#define CYAN { 0, 255, 255, 255 }
#define MAGENTA { 255, 0, 255, 255 }
#define ORANGE { 255, 165, 0, 255 }
#define PURPLE { 128, 0, 128, 255 }
#define PINK { 255, 192, 203, 255 }
#define LIME { 0, 255, 0, 255 }
#define BROWN { 139, 69, 19, 255 }
#define GRAY { 128, 128, 128, 255 }
#define LIGHT_GRAY { 192, 192, 192, 255 }
#define DARK_GRAY { 64, 64, 64, 255 }
#define SILVER { 192, 192, 192, 255 }
#define GOLD { 255, 215, 0, 255 }
#define BEIGE { 245, 245, 220, 255 }
#define INDIGO { 75, 0, 130, 255 }
#define VIOLET { 148, 0, 211, 255 }
#define MAROON { 128, 0, 0, 255 }
#define NAVY { 0, 0, 128, 255 }
#define TEAL { 0, 128, 128, 255 }
#define OLIVE { 128, 128, 0, 255 }
#define SKY_BLUE { 135, 206, 235, 255 }
#define DARK_RED { 139, 0, 0, 255 }
#define DARK_GREEN { 0, 100, 0, 255 }
#define DARK_BLUE { 0, 0, 139, 255 }
#define CYBER_YELLOW { 255, 255, 0, 128 }
#define TURQUOISE { 64, 224, 208, 255 }
#define SALMON { 250, 128, 114, 255 }
#define CORAL { 255, 127, 80, 255 }
#define LAVENDER { 230, 230, 250, 255 }
#define CHOCOLATE { 210, 105, 30, 255 }
#define TOMATO { 255, 99, 71, 255 }
#define PLUM { 221, 160, 221, 255 }
#define GOLDENROD { 218, 165, 32, 255 }
#define PERU { 205, 133, 63, 255 }
#define DARK_ORCHID { 153, 50, 204, 255 }
#define SPRING_GREEN { 0, 255, 127, 255 }
#define CRIMSON { 220, 20, 60, 255 }
#define FIREBRICK { 178, 34, 34, 255 }
#define PALE_GREEN { 152, 251, 152, 255 }
#define DARK_SLATE_GRAY { 47, 79, 79, 255 }
#define MEDIUM_AQUAMARINE { 102, 205, 170, 255 }

// define other stuff

    //earth gravity
#define EARTH_GRAVITY {0,9.81}
    // game layers
    enum Layer {
        BG_LAYER = 1,
        GAME_LAYER = 2,
        UI_LAYER  = 3,
    };
    enum Obj_Shape {
        CIRCLE_SHAPE = 1,
        RECT_SHAPE = 2,
        POLYGON_SHAPE = 3,
    };
    // pi
#ifndef M_PI
#define M_PI = 3.14159265358979323846
#endif

    #define SHOWN SDL_WINDOW_SHOWN // you can see the window.
    #define HIDDEN SDL_WINDOW_HIDDEN // you can't see the window
    #define FULLSCREEN SDL_WINDOW_FULLSCREEN // the window is fullscreen at start
    #define OPENGL SDL_WINDOW_OPENGL // define a window that supports openGL
    #define BORDERLESS SDL_WINDOW_BORDERLESS // define a window that does not have a border
    #define RESIZABLE SDL_WINDOW_RESIZABLE // Create a resizable window.
    #define MINIMIZED SDL_WINDOW_MINIMIZED // Create a minimized window.
    #define MAXIMIZED SDL_WINDOW_MAXIMIZED // Create a maximized window.
    #define INPUT_GRABBED SDL_WINDOW_INPUT_GRABBED // Window has grabbed input focus.
    #define INPUT_FOCUS SDL_WINDOW_INPUT_FOCUS // Window has input focus.
    #define MOUSE_FOCUS SDL_WINDOW_MOUSE_FOCUS // Window has mouse focus.

    enum OS {
        WINDOWS = 0,
        LINUX = 1,
        MAC = 2,
        ANDROID = 3,
        IOS = 4,
        OTHER = 5,
    };

    OS Get_OS() {
#ifdef _WIN32
        return WINDOWS;
#elif __linux__
        return LINUX;
#elif __APPLE__ && __MACH__
        return MAC;
#elif __ANDROID__
        return ANDROID;
#elif __APPLE__
        return IOS;
#else
        return OTHER;
#endif
    }

    //------------------------
    //        classes        |
    // -----------------------

    // a button, made for ease of use
    struct button {
        int x;
        int y;
        int w;
        int h;
        bool pressed = false;
        button() {}
        button(int _x, int _y, int _w, int _h) {
            x = _x;
            y = _y;
            w = _w;
            h = _h;
        }
        void press(int mx, int my, bool clicking) {
            pressed = (mx > x and mx < x + w and my > y and my < y + h) && clicking;
        }
    };
    // ease.
    class Ease {
    private:
        double time;
        double from;
        double to;
        int mode;
        double TimeAtStart;

    public:

        Ease(double atime, double afrom, double ato, int amode) {
            time = atime;
            from = afrom;
            to = ato;
            mode = amode;
            reset();
        }
        double elapsed;
        bool done = false;

        double Get_Ease() {
            elapsed = (SDL_GetTicks() - TimeAtStart) / 1000;
            if (time <= 0.0) {
                std::cerr << "Error: Total duration must be greater than zero." << std::endl;
                return 0.0;
            }

            // Ensure elapsedTime is within the valid range [0, totalDuration]
            elapsed = ((elapsed < time ? elapsed : time) < 0.0 ? 0.0 : (elapsed < time ? elapsed : time));
            if (elapsed == time) done = true;

            // Calculate A as a percentage of elapsed time over total duration
            double A = (elapsed / time) * 100.0;
            double B = from;
            double C = to;
            int D = mode;
            switch (D - 1) {
            case 0:
                return (((C - B) / 100) * A) + B;
            case 1:
                return B + ((SineIn(A)) * (C - B));
            case 2:
                return B + (SineOut(A) * (C - B));
            case 3:
                return B + ((SineInOut(A)) * (C - B));
            case 4:
                return B + (CubicIn(A) * (C - B));
            case 5:
                return B + (CubicOut(A) * (C - B));
            case 6:
                return B + (CubicInOut(A) * (C - B));
            case 7:
                return B + (QuintIn(A) * (C - B));
            case 8:
                return B + (QuintOut(A) * (C - B));
            case 9:
                return B + (QuintInOut(A) * (C - B));
            case 10:
                return B + (CircIn(A) * (C - B));
            case 11:
                return B + (CircOut(A) * (C - B));
            case 12:
                return B + (CircInOut(A) * (C - B));
            case 13:
                return B + (ElasticIn(A) * (C - B));
            case 14:
                return B + (ElasticOut(A) * (C - B));
            case 15:
                return B + (ElasticInOut(A) * (C - B));
            case 16:
                return B + (QuadIn(A) * (C - B));
            case 17:
                return B + (QuadOut(A) * (C - B));
            case 18:
                return B + (QuadInOut(A) * (C - B));
            case 19:
                return B + (QuartIn(A) * (C - B));
            case 20:
                return B + (QuartOut(A) * (C - B));
            case 21:
                return B + (QuartInOut(A) * (C - B));
            case 22:
                return B + (ExpoIn(A) * (C - B));
            case 23:
                return B + (ExpoOut(A) * (C - B));
            case 24:
                return B + (ExpoInOut(A) * (C - B));
            case 25:
                return B + (BackIn(A) * (C - B));
            case 26:
                return B + (BackOut(A) * (C - B));
            case 27:
                return B + (BackInOut(A) * (C - B));
            case 28:
                return B + ((BounceIn(A / 100)) * (C - B));
            case 29:
                return B + ((BounceOut(A / 100)) * (C - B));
            case 30:
                return B + ((BounceInOut(A / 100)) * (C - B));
            default:
                return 0;
            }
            // MADE BY JR01
        }
        void reset() {
            TimeAtStart = SDL_GetTicks();
            done = false;
        }

    private:
        //------------------------
        //        EASES          |
        //------------------------

        double SineIn(double A) {
            return 1 - cos((A / 100) * M_PI / 2);
        }
        double SineOut(double A) {
            return std::sin((A / 100) * M_PI / 2);
        }
        double SineInOut(double A) {
            return -(std::cos(M_PI * (A / 100)) - 1) / 2;
        }
        double CubicIn(double A) {
            return std::pow(A / 100, 3);
        }
        double CubicOut(double A) {
            return 1 - std::pow(1 - A / 100, 3);
        }
        double CubicInOut(double A) {
            return (A / 100) < 0.5 ? 4 * std::pow(A / 100, 3) : 1 - std::pow(-2 * (A / 100) + 2, 3) / 2;
        }
        double QuintIn(double A) {
            return std::pow(A / 100, 5);
        }
        double QuintOut(double A) {
            return 1 - std::pow(1 - A / 100, 5);
        }
        double QuintInOut(double A) {
            return (A / 100) < 0.5 ? 16 * std::pow(A / 100, 5) : 1 - std::pow(-2 * (A / 100) + 2, 5) / 2;
        }
        double CircIn(double A) {
            return 1 - std::sqrt(1 - std::pow(A / 100, 2));
        }
        double CircOut(double A) {
            return std::sqrt(1 - std::pow(A / 100 - 1, 2));
        }
        double CircInOut(double A) {
            return (A / 100) < 0.5 ? (1 - std::sqrt(1 - std::pow(2 * (A / 100), 2))) / 2 : (std::sqrt(1 - std::pow(-2 * (A / 100) + 2, 2)) + 1) / 2;
        }
        double ElasticIn(double A) {
            double c4 = (2 * M_PI) / 3;
            return (A / 100) == 0 ? 0 : (A / 100) == 1 ? 1 : -std::pow(2, 10 * (A / 100) - 10) * std::sin(((A / 100) * 10 - 10.75) * c4);
        }
        double ElasticOut(double A) {
            double c4 = (2 * M_PI) / 3;
            return (A / 100) == 0 ? 0 : (A / 100) == 1 ? 1 : std::pow(2, -10 * (A / 100)) * std::sin(((A / 100) * 10 - 0.75) * c4) + 1;
        }
        double ElasticInOut(double A) {
            double c5 = (2 * M_PI) / 4.5;
            return (A / 100) == 0 ? 0 : (A / 100) == 1 ? 1 : (A / 100) < 0.5 ? -(std::pow(2, 20 * (A / 100) - 10) * std::sin((20 * (A / 100) - 11.125) * c5)) / 2 : (std::pow(2, -20 * (A / 100) + 10) * std::sin((20 * (A / 100) - 11.125) * c5)) / 2 + 1;
        }
        double QuadIn(double A) {
            return std::pow(A / 100, 2);
        }
        double QuadOut(double A) {
            return 1 - (1 - A / 100) * (1 - A / 100);
        }
        double QuadInOut(double A) {
            return (A / 100) < 0.5 ? 2 * std::pow(A / 100, 2) : 1 - std::pow(-2 * (A / 100) + 2, 2) / 2;
        }
        double QuartIn(double A) {
            return std::pow(A / 100, 4);
        }
        double QuartOut(double A) {
            return 1 - std::pow(1 - A / 100, 4);
        }
        double QuartInOut(double A) {
            return (A / 100) < 0.5 ? 8 * std::pow(A / 100, 4) : 1 - std::pow(-2 * (A / 100) + 2, 4) / 2;
        }
        double ExpoIn(double A) {
            return (A / 100) == 0 ? 0 : std::pow(2, 10 * (A / 100) - 10);
        }
        double ExpoOut(double A) {
            return (A / 100) == 1 ? 1 : 1 - std::pow(2, -10 * (A / 100));
        }
        double ExpoInOut(double A) {
            return (A / 100) == 0 ? 0 : (A / 100) == 1 ? 1 : (A / 100) < 0.5 ? std::pow(2, 20 * (A / 100) - 10) / 2 : (2 - std::pow(2, -20 * (A / 100) + 10)) / 2;
        }
        double BackIn(double A) {
            double c1 = 1.70158;
            double c3 = c1 + 1;
            return c3 * std::pow(A / 100, 3) - c1 * std::pow(A / 100, 2);
        }
        double BackOut(double A) {
            double c1 = 1.70158;
            double c3 = c1 + 1;
            return 1 + c3 * std::pow(A / 100 - 1, 3) + c1 * std::pow(A / 100 - 1, 2);
        }
        double BackInOut(double A) {
            double c1 = 1.70158;
            double c2 = c1 * 1.525;
            return (A / 100) < 0.5 ? (std::pow(2 * (A / 100), 2) * ((c2 + 1) * 2 * (A / 100) - c2)) / 2 : (std::pow(2 * (A / 100) - 2, 2) * ((c2 + 1) * ((A / 100) * 2 - 2) + c2) + 2) / 2;
        }
        double BounceOut(double A) {
            double n1 = 7.5625;
            double d1 = 2.75;
            if (A < 1 / d1) {
                return n1 * A * A;
            }
            else if (A < 2 / d1) {
                return n1 * (A -= 1.5 / d1) * A + 0.75;
            }
            else if (A < 2.5 / d1) {
                return n1 * (A -= 2.25 / d1) * A + 0.9375;
            }
            else {
                return n1 * (A -= 2.625 / d1) * A + 0.984375;
            }
        }
        double BounceIn(double A) {
            return 1 - BounceOut(1 - A);
        }
        double BounceInOut(double A) {
            return A < 0.5 ? (1 - BounceOut(1 - 2 * A)) / 2 : (1 + BounceOut(2 * A - 1)) / 2;
        }
    };
    // a timer, based on real time. 
    class Timer {

    private:
        std::chrono::high_resolution_clock::time_point startTime;

    public:
        Timer() {
            Reset();
        }

        void Reset() {
            startTime = std::chrono::high_resolution_clock::now();
        }

        double Get_Time() const {
            auto currentTime = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> elapsedTime = currentTime - startTime;
            return elapsedTime.count();
        }
    };
    struct animation {
        std::string file = "NULL";
        int rowCount = 1;
        int coloumnCount = 1;
        int frameCount = 1;
        int sheetW = 1;
        int sheetH = 1;
        double duration;
        animation(std::string f, int rC, int cC, int _sheetW, int _sheetH, double dur) {
            file = f;
            rowCount = rC;
            coloumnCount = cC;
            sheetW = _sheetW;
            sheetH = _sheetH;
            duration = dur;
            frameCount = rowCount * coloumnCount;
        }
        int currentFrame = 0;
        double elapsedTime = 0;
    };
    struct camera {
        int x = 0;
        int y = 0;
        int wW = 1;
        int wH = 1;
        double zoom = 100;
        camera() {}
        camera(int X, int Y, int WW, int WH) {
            x = X;
            y = Y;
            wW = WW;
            wH = WH;
        }
    };

    namespace No_Physics {

        struct _texture {

            SDL_Rect dst;
            SDL_Texture* texture;
            Layer layer;
            int x, y, w, h;
            double angle;
            SDL_RendererFlip flip = SDL_FLIP_NONE;
            int displayOrder = 99999;
            _texture(int X, int Y, int W, int H, double Angle, SDL_Texture* _texture, SDL_Rect dest, Layer gamel) {
                texture = _texture;
                x = X;
                y = Y;
                w = W;
                h = H;
                angle = Angle;
                layer = gamel;
                dst = dest;
            }
        };
        
        class Window {
        public:
            
            bool operator== (Window o) {
                return win == o.win;
            }

            // the window itself,for sdl functions
            SDL_Window* win = nullptr;
            // window dimensions
            int W = 2, H = 2;
            // window display name
            std::string name = "window";
            // the window renderer, for sdl functions
            SDL_Renderer* rend = nullptr;
            // the window events

            // arguements: name,width,height,resizable (bool)
            Window(std::string _name, int _W, int _H, Uint32 flags = SHOWN) {

                if (SDL_Init(SDL_INIT_EVERYTHING) != 0) {
                    SDL_Log("Unable to initialize SDL: %s", SDL_GetError());
                    return;
                }
                win = SDL_CreateWindow(_name.c_str(), SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, _W, _H, flags);
                name = _name;
                if (!win) {
                    SDL_Log("Failed to create window: %s", SDL_GetError());
                    SDL_Quit();
                    return;
                }
                TTF_Init();

                rend = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED);

                if (!rend) {
                    SDL_Log("Failed to create renderer: %s", SDL_GetError());
                    SDL_DestroyWindow(win);
                    SDL_Quit();
                    return;
                }
                W = _W;
                H = _H;
                cam.wW = W;
                cam.wH = H;
            }

            //----------------------------
            //           GENERAL         |
            //----------------------------

            // this is the most important function in this entire class.

            // add it to your while loop argument, and it will update the window,

            // and if you are using physics it will also update that.

            virtual bool Run() {
                // events
                Get_Events();
                // delta time
                dt = Get_DT();

                // fps cap
                Cap_FPS((max_FPS == 0 ? 2000 : max_FPS));

                // mouse lock
                if (m_lock) {
                    SDL_SetRelativeMouseMode(SDL_TRUE);
                    int x, y;

                    SDL_GetRelativeMouseState(&x, &y);
                    m_x += x;
                    m_y += y;
                }
                else {
                    SDL_SetRelativeMouseMode(SDL_FALSE);
                }

                // zoom
                double z = cam.zoom / 100;
                SDL_RenderSetScale(rend, z, z);

                // window size
                SDL_GetWindowSize(win, &W, &H);

                // fullscreen
                if (fullscreen) {
                    SDL_SetWindowFullscreen(win, SDL_WINDOW_FULLSCREEN);
                    if (k_escape_pressed) fullscreen = false;
                }
                else {
                    SDL_SetWindowFullscreen(win, 0);
                }

                // show cursor
                SDL_ShowCursor(m_show);

                // mouse pos
                if (!m_lock) SDL_GetMouseState(&m_x, &m_y);

                // get fps
                fps = FPS();

                // window title
                std::string new_name = (!display_FPS ? name : name + "    fps: " + std::to_string(fps));
                SDL_SetWindowTitle(win, new_name.c_str());

                // sort the sprites based on a display order
                
                // draw sprites
                for (_texture i : textures) {
                    SDL_Rect src = { i.x, i.y, i.w, i.h };
                    if (i.layer == BG_LAYER) SDL_RenderCopyEx(rend, i.texture, &i.dst, &src, i.angle, NULL, i.flip);
                }
                for (_texture i : textures) {

                    SDL_Rect src = { i.x, i.y, i.w, i.h };
                    if (i.layer = BG_LAYER) SDL_RenderCopyEx(rend, i.texture, &i.dst, &src, i.angle, NULL, i.flip);
                }
                for (_texture i : textures) {
                    SDL_Rect src = { i.x, i.y, i.w, i.h };
                    if (i.layer == UI_LAYER) SDL_RenderCopyEx(rend, i.texture, &i.dst, &src, i.angle, NULL, i.flip);
                }

                // update the window
                SDL_RenderPresent(rend);


                // clear the window
                if (clear) {
                    Clear();
                }
                
                Update();
                textures = {};
                if (!running) {
                    SDL_DestroyWindow(win);
                    SDL_DestroyRenderer(rend);
                }
                return running;
            }
            virtual void Update() {}
            // if the window is full screen ( fullscreen will automatically stop when you press the esc key.)
            bool fullscreen = false;

            // display fps on the window
            bool display_FPS = false;

            // fps as a variable
            int fps = 0;

            // delta time for animations and movement

            // delta time is the time since the last frame.
            double dt = 0;

            // set max frame rate
            int max_FPS = 0;


            // the window color
            SDL_Color color = { 255,255,255,255 };

            // clear the window with the window color.
            bool clear = true;

            // set window icon (this will not really work when you export your app,

            // the icon will just be the app icon
            void Set_Icon(std::string file) {
                SDL_Surface* s = SDL_LoadBMP(file.c_str());
                SDL_SetWindowIcon(win, s);
            }

            bool inView(b2Vec2 i, int viewBufferPixels = 0) {
                return (i.x > W + viewBufferPixels || i.x < 0 - viewBufferPixels || i.y > H + viewBufferPixels || i.y < 0 - viewBufferPixels);

            }

            //--------------------------
            //         DRAW            |
            //--------------------------
            
            SDL_Texture* Load_Sprite(std::string file) {
                SDL_Texture* spriteTexture = SDL_CreateTextureFromSurface(rend, SDL_LoadBMP(file.c_str()));
                if (!spriteTexture) {
                    SDL_Log("Unable to load sprite texture: %s", SDL_GetError());
                }
                return spriteTexture;
            }
            
            void Draw_String(int x, int y, int size, double angle, std::string text, std::string f, SDL_Color color) {
                TTF_Font* font = TTF_OpenFont(f.c_str(), size);
                if (!rend || !font) {
                    std::cerr << "Renderer or font is invalid." << std::endl;
                    return;
                }

                // Create a transformation matrix for rotating the text
                SDL_Point center = { x, y };
                SDL_Rect textRect = { 0, 0, 0, 0 };
                SDL_Surface* textSurface = nullptr;
                SDL_Texture* textTexture = nullptr;

                // Rotate the text
                if (angle != 0.0) {
                    SDL_Surface* tempSurface = TTF_RenderText_Solid(font, text.c_str(), color);
                    if (!tempSurface) {
                        std::cerr << "Text rendering failed: " << TTF_GetError() << std::endl;
                        return;
                    }

                    SDL_Texture* tempTexture = SDL_CreateTextureFromSurface(rend, tempSurface);
                    SDL_FreeSurface(tempSurface);
                    if (!tempTexture) {
                        std::cerr << "Texture creation failed: " << SDL_GetError() << std::endl;
                        return;
                    }

                    SDL_QueryTexture(tempTexture, nullptr, nullptr, &textRect.w, &textRect.h);

                    SDL_SetRenderTarget(rend, nullptr);

                    SDL_RenderCopyEx(rend, tempTexture, nullptr, &textRect, angle, &center, SDL_FLIP_NONE);

                    SDL_DestroyTexture(tempTexture);
                }
                else {
                    textSurface = TTF_RenderText_Solid(font, text.c_str(), color);
                    if (!textSurface) {
                        std::cerr << "Text rendering failed: " << TTF_GetError() << std::endl;
                        return;
                    }

                    textTexture = SDL_CreateTextureFromSurface(rend, textSurface);
                    if (!textTexture) {
                        std::cerr << "Texture creation failed: " << SDL_GetError() << std::endl;
                        return;
                    }

                    SDL_QueryTexture(textTexture, nullptr, nullptr, &textRect.w, &textRect.h);
                }

                textRect.x = x;
                textRect.y = y;
                textRect.w = int(size * textRect.w / textRect.h);
                textRect.h = size;

                SDL_RenderCopyEx(rend, textTexture, nullptr, &textRect, angle, &center, SDL_FLIP_NONE);
                SDL_DestroyTexture(textTexture);
                SDL_FreeSurface(textSurface);


            }
            SDL_Rect Get_String_Rect(int x, int y, int size, double angle, std::string text, std::string f, SDL_Color color) {
                TTF_Font* font = TTF_OpenFont(f.c_str(), size);
                if (!rend || !font) {
                    std::cerr << "Renderer or font is invalid." << std::endl;
                    return { 0,0,0,0 };
                }

                // Create a transformation matrix for rotating the text
                SDL_Point center = { x, y };
                SDL_Rect textRect = { 0, 0, 0, 0 };
                SDL_Surface* textSurface = nullptr;
                SDL_Texture* textTexture = nullptr;

                // Rotate the text
                if (angle != 0.0) {
                    SDL_Surface* tempSurface = TTF_RenderText_Solid(font, text.c_str(), color);
                    if (!tempSurface) {
                        std::cerr << "Text rendering failed: " << TTF_GetError() << std::endl;
                        return{ 0,0,0,0 };
                    }

                    SDL_Texture* tempTexture = SDL_CreateTextureFromSurface(rend, tempSurface);
                    SDL_FreeSurface(tempSurface);
                    if (!tempTexture) {
                        std::cerr << "Texture creation failed: " << SDL_GetError() << std::endl;
                        return{ 0,0,0,0 };
                    }

                    SDL_QueryTexture(tempTexture, nullptr, nullptr, &textRect.w, &textRect.h);

                    SDL_SetRenderTarget(rend, nullptr);

                    SDL_RenderCopyEx(rend, tempTexture, nullptr, &textRect, angle, &center, SDL_FLIP_NONE);

                    SDL_DestroyTexture(tempTexture);
                }
                else {
                    textSurface = TTF_RenderText_Solid(font, text.c_str(), color);
                    if (!textSurface) {
                        std::cerr << "Text rendering failed: " << TTF_GetError() << std::endl;
                        return{ 0,0,0,0 };
                    }

                    textTexture = SDL_CreateTextureFromSurface(rend, textSurface);
                    if (!textTexture) {
                        std::cerr << "Texture creation failed: " << SDL_GetError() << std::endl;
                        return{ 0,0,0,0 };
                    }

                    SDL_QueryTexture(textTexture, nullptr, nullptr, &textRect.w, &textRect.h);
                }

                textRect.x = x;
                textRect.y = y;
                textRect.w = int(size * textRect.w / textRect.h);
                textRect.h = size;

                SDL_DestroyTexture(textTexture);
                SDL_FreeSurface(textSurface);
                return textRect;

            }


            // draw a pixel on the screen
            void Draw(int x, int y, SDL_Color color) {
                SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                SDL_RenderDrawPoint(rend, x, y);
            }
            void Draw(b2Vec2 point, SDL_Color color) {
                SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                SDL_RenderDrawPoint(rend, point.x, point.y);
                // Optionally use 'layer' argument for layer-specific logic
            }

            void Draw_Texture(int x, int y, int width, int height, double angle, SDL_Texture* t, SDL_Rect sorcrect = { 10,10,9,9 }, Layer layer = GAME_LAYER, int DisplayOrder = 99999, SDL_RendererFlip flip = SDL_FLIP_NONE) {
                SDL_Rect src = { static_cast<int> (x), static_cast<int> (y), static_cast<int> (width), static_cast<int> (height) };
                if (sorcrect.x == 10 && sorcrect.y == 10 && sorcrect.w == 9 && sorcrect.h == 9) sorcrect = { 0,0,W,H };
                _texture te = { x,y,width,height,angle,t, sorcrect, layer };
                te.displayOrder = DisplayOrder;
                te.flip = flip;
                textures.push_back(te);
            }
            void Draw_Sprite(int x, int y, int width, int height, double angle, std::string file, SDL_Rect sorcrect = { 10,10,9,9 }, Layer layer = GAME_LAYER, int DisplayOrder = 99999, SDL_RendererFlip flip = SDL_FLIP_NONE) {
                SDL_Texture* spriteTexture = SDL_CreateTextureFromSurface(rend, SDL_LoadBMP(file.c_str()));
                SDL_Rect src = { x,y,width,height };
                if (sorcrect.x == 10 && sorcrect.y == 10 && sorcrect.w == 9 && sorcrect.h == 9) sorcrect = { 0,0,W,H };

                _texture te = { x,y,width,height,angle, spriteTexture, sorcrect, layer };
                te.displayOrder = DisplayOrder;
                te.flip = flip;
                textures.push_back(te);
            }

            // draw a rectangle outline
            void Draw_Rect(int X, int Y, int W, int H, SDL_Color color) {
                int R = color.r;
                int G = color.g;
                int B = color.b;
                int A = color.a;
                SDL_Rect squareRect = { X, Y, W, H };

                SDL_SetRenderDrawColor(rend, R, G, B, A);
                SDL_RenderDrawRect(rend, &squareRect);
                // Optionally use 'layer' argument for layer-specific logic
            }
            void Draw_Rect(b2Vec2 pos, int w, int h, SDL_Color color) {
                int R = color.r;
                int G = color.g;
                int B = color.b;
                int A = color.a;
                SDL_Rect squareRect = { pos.x, pos.y, w, h };

                SDL_SetRenderDrawColor(rend, R, G, B, A);
                SDL_RenderDrawRect(rend, &squareRect);
                // Optionally use 'layer' argument for layer-specific logic
            }

            // draw a line
            void Draw_Line(int X, int Y, int X1, int Y1, SDL_Color color) {
                int R = color.r;
                int G = color.g;
                int B = color.b;
                int A = color.a;
                SDL_SetRenderDrawColor(rend, R, G, B, A);
                SDL_RenderDrawLine(rend, X, Y, X1, Y1);
            }
            void Draw_Line(b2Vec2 pos, b2Vec2 pos2, SDL_Color color) {
                int R = color.r;
                int G = color.g;
                int B = color.b;
                int A = color.a;
                SDL_SetRenderDrawColor(rend, R, G, B, A);
                SDL_RenderDrawLine(rend, pos.x, pos.y, pos2.x, pos2.y);
            }

            // draw a filled rectangle
            void Fill_Rect(int X, int Y, int W, int H, SDL_Color color) {
                int R = color.r;
                int G = color.g;
                int B = color.b;
                int A = color.a;
                SDL_Rect squareRect = { X, Y, W, H };

                SDL_SetRenderDrawBlendMode(rend, SDL_BLENDMODE_BLEND);
                SDL_SetRenderDrawColor(rend, R, G, B, A);
                SDL_RenderFillRect(rend, &squareRect);
                // Optionally use 'layer' argument for layer-specific logic
            }
            void Fill_Rect(b2Vec2 pos, int W, int H, SDL_Color color) {
                int R = color.r;
                int G = color.g;
                int B = color.b;
                int A = color.a;
                SDL_Rect squareRect = { pos.x, pos.y, W, H };

                SDL_SetRenderDrawBlendMode(rend, SDL_BLENDMODE_BLEND);
                SDL_SetRenderDrawColor(rend, R, G, B, A);
                SDL_RenderFillRect(rend, &squareRect);
                // Optionally use 'layer' argument for layer-specific logic
            }

            // draw and fill a circle
            void Draw_Circle(int x, int y, int rad, SDL_Color color) {
                b2Vec2 last = AngleAndDistance_To(x, y, 0, rad / 2);
                b2Vec2 first = last;
                for (int angle = 1; angle <= 360; angle++) {
                    b2Vec2 point = AngleAndDistance_To(x, y, angle, rad / 2);
                    SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                    SDL_RenderDrawLine(rend, last.x, last.y, point.x, point.y);
                    last = point;
                }
            }
            void Fill_Circle(int x, int y, int rad, SDL_Color color) {

                b2Vec2 last = AngleAndDistance_To(x, y, 0, rad / 2);
                b2Vec2 first = last;
                for (int angle = 1; angle <= 360; angle++) {
                    b2Vec2 point = AngleAndDistance_To(x, y, angle, rad / 2);

                    std::vector<SDL_Vertex> vertexArray {
                        {{last.x, last.y }, color, { point.x, point.y }},
                        { {point.x, point.y },	color, { static_cast<float> (x), static_cast<float> (y) } },
                        { {static_cast<float> (x), static_cast<float> (y)},	color, {last.x, last.y} },
                    };

                    // Now you can use vertexArray in your SDL_RenderGeometry function call
                    SDL_RenderGeometry(rend, NULL, vertexArray.data(), 3, NULL, 0);

                    last = point;
                }
            }

            // draw and fill a non convex polygon shape
            void Draw_Polygon(int x, int y, std::vector<b2Vec2> v, SDL_Color c) {
                if (v.size() < 2) return;

                b2Vec2 first = v[0];
                b2Vec2 previous = first;

                for (size_t i = 1; i < v.size(); i++) {
                    b2Vec2 current = v[i];
                    Draw_Line(previous.x + x, previous.y + y, current.x + x, current.y + y, c);
                    previous = current;
                }

                // Connect the last point to the first one to close the shape
                Draw_Line(previous.x + x, previous.y + y, first.x + x, first.y + y, c);

            }
            void Fill_Polygon(int x, int y, std::vector<b2Vec2> vertices, const SDL_Color color) {
                int n = vertices.size();

                SDL_Vertex* verts = new SDL_Vertex[n];
                for (int i = 0; i < n; i++) {
                    verts[i].position.x = vertices[i].x + x;
                    verts[i].position.y = vertices[i].y + y;
                    verts[i].color = color;
                }

                int* indices = new int[(n - 2) * 3];
                for (int i = 1; i < n - 1; i++) {
                    indices[3 * (i - 1)] = 0;
                    indices[3 * i - 2] = i;
                    indices[3 * i - 1] = i + 1;
                }

                SDL_RenderGeometry(rend, NULL, verts, n, indices, (n - 2) * 3);
                delete indices;
                delete verts;
            }


            // draw a sprite sheet animation
            void Draw_Animation(int x, int y, int w, int h, double angle, animation* an, int displayOrder = 99999, Layer layer = GAME_LAYER, SDL_RendererFlip flip = SDL_FLIP_NONE) {
                double frameDuration = an->duration / an->frameCount;
                an->elapsedTime += dt;
                int NextFrame = an->currentFrame + 1;
                std::cout << "current frame: " << an->currentFrame << "\n";

                Draw_Frame(an->currentFrame, x, y, w, h, angle, an, layer, displayOrder, flip);

                if (an->elapsedTime >= frameDuration * NextFrame) an->currentFrame++;
                if (an->elapsedTime >= an->duration) {
                    an->currentFrame = 0;
                    an->elapsedTime = 0;
                }

            }
            void Draw_Frame(int frameIndex, int x, int y, int w, int h, double angle, animation* an, Layer layer = GAME_LAYER, int displayOrder = 99999, SDL_RendererFlip flip = SDL_FLIP_NONE) {
                if (frameIndex >= an->frameCount) return;

                int frameWidth = an->sheetW / an->coloumnCount;
                int frameHeight = an->sheetH / an->rowCount;

                // Calculate the position of the frame on the sprite sheet based on frameIndex
                int frameX = (frameIndex % an->coloumnCount) * frameWidth;
                int frameY = (frameIndex / an->coloumnCount) * frameHeight;

                // Calculate the scaled frame width and height based on w and h arguments
                int scaledFrameWidth = w;
                int scaledFrameHeight = h;

                SDL_Rect r = { frameX, frameY, frameWidth, frameHeight };

                // Call Draw_Sprite to draw the frame from the sprite sheet with the specified w and h
                Draw_Sprite(x, y, scaledFrameWidth, scaledFrameHeight, angle, an->file, r, layer, displayOrder, flip);
            }


            //---------------------------
            //           OTHER          |
            //---------------------------

            // get events that are not already detected by the class
            bool Event_Loop() {
                static int iteration = 0;
                if (iteration == events.size()) {
                    iteration = 0;
                    return false;
                }
                event = events[iteration];
                iteration++;

                event.window.windowID = SDL_GetWindowID(win);
                return true;
            }

            // event that you got from the Event_Loop() function
            SDL_Event event;

            // game camera, this only affects sprites and shapes tagged with GAME_OBJECT
            camera cam = { 0,0,W,H };

            void Close() { running = false; }

            std::vector<_texture> textures;
            //--------------------
            //       KEYS        |
            //--------------------

            bool k_a_pressed = false;
            bool k_a_held = false;
            bool k_a_released = false;

            bool k_b_pressed = false;
            bool k_b_held = false;
            bool k_b_released = false;

            bool k_c_pressed = false;
            bool k_c_held = false;
            bool k_c_released = false;

            bool k_d_pressed = false;
            bool k_d_held = false;
            bool k_d_released = false;

            bool k_e_pressed = false;
            bool k_e_held = false;
            bool k_e_released = false;

            bool k_f_pressed = false;
            bool k_f_held = false;
            bool k_f_released = false;

            bool k_g_pressed = false;
            bool k_g_held = false;
            bool k_g_released = false;

            bool k_h_pressed = false;
            bool k_h_held = false;
            bool k_h_released = false;

            bool k_i_pressed = false;
            bool k_i_held = false;
            bool k_i_released = false;

            bool k_j_pressed = false;
            bool k_j_held = false;
            bool k_j_released = false;

            bool k_k_pressed = false;
            bool k_k_held = false;
            bool k_k_released = false;

            bool k_l_pressed = false;
            bool k_l_held = false;
            bool k_l_released = false;

            bool k_m_pressed = false;
            bool k_m_held = false;
            bool k_m_released = false;

            bool k_n_pressed = false;
            bool k_n_held = false;
            bool k_n_released = false;

            bool k_o_pressed = false;
            bool k_o_held = false;
            bool k_o_released = false;

            bool k_p_pressed = false;
            bool k_p_held = false;
            bool k_p_released = false;

            bool k_q_pressed = false;
            bool k_q_held = false;
            bool k_q_released = false;

            bool k_r_pressed = false;
            bool k_r_held = false;
            bool k_r_released = false;

            bool k_s_pressed = false;
            bool k_s_held = false;
            bool k_s_released = false;

            bool k_t_pressed = false;
            bool k_t_held = false;
            bool k_t_released = false;

            bool k_u_pressed = false;
            bool k_u_held = false;
            bool k_u_released = false;

            bool k_v_pressed = false;
            bool k_v_held = false;
            bool k_v_released = false;

            bool k_w_pressed = false;
            bool k_w_held = false;
            bool k_w_released = false;

            bool k_x_pressed = false;
            bool k_x_held = false;
            bool k_x_released = false;

            bool k_y_pressed = false;
            bool k_y_held = false;
            bool k_y_released = false;

            bool k_z_pressed = false;
            bool k_z_held = false;
            bool k_z_released = false;

            // Additional commonly used keys
            bool k_space_pressed = false;
            bool k_space_held = false;
            bool k_space_released = false;

            bool k_enter_pressed = false;
            bool k_enter_held = false;
            bool k_enter_released = false;

            bool k_escape_pressed = false;
            bool k_escape_held = false;
            bool k_escape_released = false;

            bool k_shift_pressed = false;
            bool k_shift_held = false;
            bool k_shift_released = false;

            bool k_ctrl_pressed = false;
            bool k_ctrl_held = false;
            bool k_ctrl_released = false;

            bool k_alt_pressed = false;
            bool k_alt_held = false;
            bool k_alt_released = false;

            // Special characters
            bool k_semicolon_pressed = false;
            bool k_semicolon_held = false;
            bool k_semicolon_released = false;

            bool k_apostrophe_pressed = false;
            bool k_apostrophe_held = false;
            bool k_apostrophe_released = false;

            bool k_period_pressed = false;
            bool k_period_held = false;
            bool k_period_released = false;

            bool k_comma_pressed = false;
            bool k_comma_held = false;
            bool k_comma_released = false;

            bool k_slash_pressed = false;
            bool k_slash_held = false;
            bool k_slash_released = false;

            bool k_backslash_pressed = false;
            bool k_backslash_held = false;
            bool k_backslash_released = false;

            bool k_asterisk_pressed = false;
            bool k_asterisk_held = false;
            bool k_asterisk_released = false;

            bool k_equals_pressed = false;
            bool k_equals_held = false;
            bool k_equals_released = false;

            bool k_minus_pressed = false;
            bool k_minus_held = false;
            bool k_minus_released = false;

            // Number keys (0-9)
            bool k_0_pressed = false;
            bool k_0_held = false;
            bool k_0_released = false;

            bool k_1_pressed = false;
            bool k_1_held = false;
            bool k_1_released = false;

            bool k_2_pressed = false;
            bool k_2_held = false;
            bool k_2_released = false;

            bool k_3_pressed = false;
            bool k_3_held = false;
            bool k_3_released = false;

            bool k_4_pressed = false;
            bool k_4_held = false;
            bool k_4_released = false;

            bool k_5_pressed = false;
            bool k_5_held = false;
            bool k_5_released = false;

            bool k_6_pressed = false;
            bool k_6_held = false;
            bool k_6_released = false;

            bool k_7_pressed = false;
            bool k_7_held = false;
            bool k_7_released = false;

            bool k_8_pressed = false;
            bool k_8_held = false;
            bool k_8_released = false;

            bool k_9_pressed = false;
            bool k_9_held = false;
            bool k_9_released = false;

            // Arrow keys
            bool k_up_pressed = false;
            bool k_up_held = false;
            bool k_up_released = false;

            bool k_down_pressed = false;
            bool k_down_held = false;
            bool k_down_released = false;

            bool k_left_pressed = false;
            bool k_left_held = false;
            bool k_left_released = false;

            bool k_right_pressed = false;
            bool k_right_held = false;
            bool k_right_released = false;

            // the window mouse events
            bool m_left_pressed = false;
            bool m_left_held = false;
            bool m_left_released = false;
            bool m_right_pressed = false;
            bool m_right_held = false;
            bool m_right_released = false;

            int m_x = 0;
            int m_y = 0;

            int m_wheel_x = 0;
            int m_wheel_y = 0;

            bool m_lock = false;
            bool m_show = true;


        protected:


            SDL_Event ev;
            std::vector<SDL_Event> events;

            // if the window is running
            bool running = true;

            bool _k_a_allowed = true;
            bool _k_b_allowed = true;
            bool _k_c_allowed = true;
            bool _k_d_allowed = true;
            bool _k_e_allowed = true;
            bool _k_f_allowed = true;
            bool _k_g_allowed = true;
            bool _k_h_allowed = true;
            bool _k_i_allowed = true;
            bool _k_j_allowed = true;
            bool _k_k_allowed = true;
            bool _k_l_allowed = true;
            bool _k_m_allowed = true;
            bool _k_n_allowed = true;
            bool _k_o_allowed = true;
            bool _k_p_allowed = true;
            bool _k_q_allowed = true;
            bool _k_r_allowed = true;
            bool _k_s_allowed = true;
            bool _k_t_allowed = true;
            bool _k_u_allowed = true;
            bool _k_v_allowed = true;
            bool _k_w_allowed = true;
            bool _k_x_allowed = true;
            bool _k_y_allowed = true;
            bool _k_z_allowed = true;
            bool _k_space_allowed = true;
            bool _k_enter_allowed = true;
            bool _k_escape_allowed = true;
            bool _k_shift_allowed = true;
            bool _k_ctrl_allowed = true;
            bool _k_alt_allowed = true;
            bool _k_semicolon_allowed = true;
            bool _k_apostrophe_allowed = true;
            bool _k_period_allowed = true;
            bool _k_comma_allowed = true;
            bool _k_slash_allowed = true;
            bool _k_backslash_allowed = true;
            bool _k_asterisk_allowed = true;
            bool _k_equals_allowed = true;
            bool _k_minus_allowed = true;
            bool _k_0_allowed = true;
            bool _k_1_allowed = true;
            bool _k_2_allowed = true;
            bool _k_3_allowed = true;
            bool _k_4_allowed = true;
            bool _k_5_allowed = true;
            bool _k_6_allowed = true;
            bool _k_7_allowed = true;
            bool _k_8_allowed = true;
            bool _k_9_allowed = true;
            bool _k_up_allowed = true;
            bool _k_down_allowed = true;
            bool _k_left_allowed = true;
            bool _k_right_allowed = true;

            int last_m_x = 0;
            int last_m_y = 0;
            double lastfps = 0;

            void Reset_Events() {
                events = {};
                // keyboard events
                k_a_pressed = false;
                k_a_released = false;
                k_b_pressed = false;
                k_b_released = false;
                k_c_pressed = false;
                k_c_released = false;
                k_d_pressed = false;
                k_d_released = false;
                k_e_pressed = false;
                k_e_released = false;
                k_f_pressed = false;
                k_f_released = false;
                k_g_pressed = false;
                k_g_released = false;
                k_h_pressed = false;
                k_h_released = false;
                k_i_pressed = false;
                k_i_released = false;
                k_j_pressed = false;
                k_j_released = false;
                k_k_pressed = false;
                k_k_released = false;
                k_l_pressed = false;
                k_l_released = false;
                k_m_pressed = false;
                k_m_released = false;
                k_n_pressed = false;
                k_n_released = false;
                k_o_pressed = false;
                k_o_released = false;
                k_p_pressed = false;
                k_p_released = false;
                k_q_pressed = false;
                k_q_released = false;
                k_r_pressed = false;
                k_r_released = false;
                k_s_pressed = false;
                k_s_released = false;
                k_t_pressed = false;
                k_t_released = false;
                k_u_pressed = false;
                k_u_released = false;
                k_v_pressed = false;
                k_v_released = false;
                k_w_pressed = false;
                k_w_released = false;
                k_x_pressed = false;
                k_x_released = false;
                k_y_pressed = false;
                k_y_released = false;
                k_z_pressed = false;
                k_z_released = false;
                k_space_pressed = false;
                k_space_released = false;
                k_enter_pressed = false;
                k_enter_released = false;
                k_escape_pressed = false;
                k_escape_released = false;
                k_shift_pressed = false;
                k_shift_released = false;
                k_ctrl_pressed = false;
                k_ctrl_released = false;
                k_alt_pressed = false;
                k_alt_released = false;
                k_semicolon_pressed = false;
                k_semicolon_released = false;
                k_apostrophe_pressed = false;
                k_apostrophe_released = false;
                k_period_pressed = false;
                k_period_released = false;
                k_comma_pressed = false;
                k_comma_released = false;
                k_slash_pressed = false;
                k_slash_released = false;
                k_backslash_pressed = false;
                k_backslash_released = false;
                k_asterisk_pressed = false;
                k_asterisk_released = false;
                k_equals_pressed = false;
                k_equals_released = false;
                k_minus_pressed = false;
                k_minus_released = false;
                k_0_pressed = false;
                k_0_released = false;
                k_1_pressed = false;
                k_1_released = false;
                k_2_pressed = false;
                k_2_released = false;
                k_3_pressed = false;
                k_3_released = false;
                k_4_pressed = false;
                k_4_released = false;
                k_5_pressed = false;
                k_5_released = false;
                k_6_pressed = false;
                k_6_released = false;
                k_7_pressed = false;
                k_7_released = false;
                k_8_pressed = false;
                k_8_released = false;
                k_9_pressed = false;
                k_9_released = false;
                k_up_pressed = false;
                k_up_released = false;
                k_down_pressed = false;
                k_down_released = false;
                k_left_pressed = false;
                k_left_released = false;
                k_right_pressed = false;
                k_right_released = false;

                m_left_pressed = false;
                m_left_released = false;
                m_right_pressed = false;
                m_right_released = false;
            }

            void Get_Events() {
                Reset_Events();
                while (SDL_PollEvent(&ev)) {
                    if (ev.type == SDL_QUIT) running = false;
                    if (ev.type == SDL_MOUSEBUTTONDOWN) {
                        if (ev.button.button == SDL_BUTTON_LEFT) {
                            m_left_pressed = true;
                            m_left_held = true;
                        }
                        if (ev.button.button == SDL_BUTTON_RIGHT) {
                            m_right_pressed = true;
                            m_right_held = true;
                        }
                    }
                    if (ev.type == SDL_MOUSEBUTTONUP) {
                        if (ev.button.button == SDL_BUTTON_LEFT) {
                            m_left_released = true;
                            m_left_held = false;
                        }
                        if (ev.button.button == SDL_BUTTON_RIGHT) {
                            m_right_released = true;
                            m_right_held = false;
                        }
                    }
                    if (ev.type == SDL_MOUSEWHEEL) m_wheel_x = ev.wheel.x, m_wheel_y = ev.wheel.y;
                    else if (ev.type == SDL_KEYDOWN) {
                        switch (ev.key.keysym.sym) {
                        case SDLK_a:

                            if (_k_a_allowed) k_a_pressed = true;
                            k_a_held = true;
                            _k_a_allowed = false;
                            break;

                        case SDLK_b:

                            if (_k_b_allowed) k_b_pressed = true;
                            k_b_held = true;
                            _k_b_allowed = false;

                            break;

                        case SDLK_c:

                            if (_k_c_allowed) k_c_pressed = true;
                            k_c_held = true;
                            _k_c_allowed = false;

                            break;

                        case SDLK_d:

                            if (_k_d_allowed) k_d_pressed = true;
                            k_d_held = true;
                            _k_d_allowed = false;

                            break;

                        case SDLK_e:

                            if (_k_e_allowed) k_e_pressed = true;
                            k_e_held = true;
                            _k_e_allowed = false;

                            break;

                        case SDLK_f:

                            if (_k_f_allowed) k_f_pressed = true;
                            k_f_held = true;
                            _k_f_allowed = false;

                            break;

                        case SDLK_g:

                            if (_k_g_allowed) k_g_pressed = true;
                            k_g_held = true;
                            _k_g_allowed = false;

                            break;

                        case SDLK_h:

                            if (_k_h_allowed) k_h_pressed = true;
                            k_h_held = true;
                            _k_h_allowed = false;

                            break;

                        case SDLK_i:

                            if (_k_i_allowed) k_i_pressed = true;
                            k_i_held = true;
                            _k_i_allowed = false;

                            break;

                        case SDLK_j:

                            if (_k_j_allowed) k_j_pressed = true;
                            k_j_held = true;
                            _k_j_allowed = false;

                            break;

                        case SDLK_k:

                            if (_k_k_allowed) k_k_pressed = true;
                            k_k_held = true;
                            _k_j_allowed = false;

                            break;

                        case SDLK_l:

                            if (_k_l_allowed) k_l_pressed = true;
                            k_l_held = true;
                            _k_l_allowed = false;

                            break;

                        case SDLK_m:

                            if (_k_m_allowed) k_m_pressed = true;
                            k_m_held = true;
                            _k_m_allowed = false;

                            break;

                        case SDLK_n:

                            if (_k_n_allowed) k_n_pressed = true;
                            k_n_held = true;
                            _k_n_allowed = false;

                            break;

                        case SDLK_o:

                            if (_k_o_allowed) k_o_pressed = true;
                            k_o_held = true;
                            _k_o_allowed = false;

                            break;

                        case SDLK_p:

                            if (_k_p_allowed) k_p_pressed = true;
                            k_p_held = true;
                            _k_p_allowed = false;

                            break;

                        case SDLK_q:

                            if (_k_q_allowed) k_q_pressed = true;
                            k_q_held = true;
                            _k_q_allowed = false;

                            break;

                        case SDLK_r:

                            if (_k_r_allowed) k_r_pressed = true;
                            k_r_held = true;
                            _k_r_allowed = false;

                            break;

                        case SDLK_s:

                            if (_k_s_allowed) k_s_pressed = true;
                            k_s_held = true;
                            _k_s_allowed = false;

                            break;

                        case SDLK_t:

                            if (_k_t_allowed) k_t_pressed = true;
                            k_t_held = true;
                            _k_t_allowed = false;

                            break;

                        case SDLK_u:

                            if (_k_u_allowed) k_u_pressed = true;
                            k_u_held = true;
                            _k_u_allowed = false;

                            break;

                        case SDLK_v:

                            if (_k_v_allowed) k_v_pressed = true;
                            k_v_held = true;
                            _k_v_allowed = false;

                            break;

                        case SDLK_w:

                            if (_k_w_allowed) k_w_pressed = true;
                            k_w_held = true;
                            _k_w_allowed = false;

                            break;

                        case SDLK_x:

                            if (_k_x_allowed) k_x_pressed = true;
                            k_x_held = true;
                            _k_x_allowed = false;

                            break;

                        case SDLK_y:

                            if (_k_y_allowed) k_y_pressed = true;
                            k_y_held = true;
                            _k_y_allowed = false;

                            break;

                        case SDLK_z:

                            if (_k_z_allowed) k_z_pressed = true;
                            k_z_held = true;
                            _k_z_allowed = false;

                            break;

                        case SDLK_SPACE:

                            if (_k_space_allowed) k_space_pressed = true;
                            k_space_held = true;
                            _k_space_allowed = false;

                            break;

                        case SDLK_RETURN:

                            if (_k_enter_allowed) k_enter_pressed = true;
                            k_enter_held = true;
                            _k_enter_allowed = false;

                            break;

                        case SDLK_ESCAPE:

                            if (_k_escape_allowed) k_escape_pressed = true;
                            k_escape_held = true;
                            _k_escape_allowed = false;

                            break;

                        case SDLK_LSHIFT:
                        case SDLK_RSHIFT:

                            if (_k_shift_allowed) k_shift_pressed = true;
                            k_shift_held = true;
                            _k_shift_allowed = false;

                            break;

                        case SDLK_LCTRL:
                        case SDLK_RCTRL:

                            if (_k_ctrl_allowed) k_ctrl_pressed = true;
                            k_ctrl_held = true;
                            _k_ctrl_allowed = false;

                            break;

                        case SDLK_LALT:
                        case SDLK_RALT:

                            if (_k_alt_allowed) k_alt_pressed = true;
                            k_alt_held = true;
                            _k_alt_allowed = false;

                            break;

                        case SDLK_SEMICOLON:

                            if (_k_semicolon_allowed) k_semicolon_pressed = true;
                            k_semicolon_held = true;
                            _k_semicolon_allowed = false;

                            break;

                        case SDLK_PERIOD:

                            if (_k_period_allowed) k_period_pressed = true;
                            k_period_held = true;
                            _k_period_allowed = false;

                            break;

                        case SDLK_COMMA:

                            if (_k_comma_allowed) k_comma_pressed = true;
                            k_comma_held = true;
                            _k_comma_allowed = false;

                            break;

                        case SDLK_SLASH:

                            if (_k_slash_allowed) k_slash_pressed = true;
                            k_slash_held = true;
                            _k_slash_allowed = false;

                            break;

                        case SDLK_BACKSLASH:

                            if (_k_backslash_allowed) k_backslash_pressed = true;
                            k_backslash_held = true;
                            _k_backslash_allowed = false;

                            break;

                        case SDLK_ASTERISK:

                            if (_k_asterisk_allowed) k_asterisk_pressed = true;
                            k_asterisk_held = true;
                            _k_asterisk_allowed = false;

                            break;

                        case SDLK_EQUALS:

                            if (_k_equals_allowed) k_equals_pressed = true;
                            k_equals_held = true;
                            _k_equals_allowed = false;

                            break;

                        case SDLK_MINUS:

                            if (_k_minus_allowed) k_minus_pressed = true;
                            k_minus_held = true;
                            _k_minus_allowed = false;

                            break;

                        case SDLK_UP:

                            if (_k_up_allowed) k_up_pressed = true;
                            k_up_held = true;
                            _k_up_allowed = false;

                            break;

                        case SDLK_DOWN:

                            if (_k_down_allowed) k_down_pressed = true;
                            k_down_held = true;
                            _k_down_allowed = false;

                            break;

                        case SDLK_LEFT:

                            if (_k_left_allowed) k_left_pressed = true;
                            k_left_held = true;
                            _k_left_allowed = false;

                            break;

                        case SDLK_RIGHT:

                            if (_k_right_allowed) k_right_pressed = true;
                            k_right_held = true;
                            _k_right_allowed = false;

                            break;
                        case SDLK_0:
                            if (_k_0_allowed) k_0_pressed = true;
                            k_0_held = true;
                            _k_0_allowed = false;
                            break;
                        case SDLK_1:
                            if (_k_1_allowed) k_1_pressed = true;
                            k_1_held = true;
                            _k_1_allowed = false;
                            break;
                        case SDLK_2:
                            if (_k_2_allowed) k_2_pressed = true;
                            k_2_held = true;
                            _k_2_allowed = false;
                            break;
                        case SDLK_3:
                            if (_k_3_allowed) k_3_pressed = true;
                            k_3_held = true;
                            _k_3_allowed = false;
                            break;
                        case SDLK_4:
                            if (_k_4_allowed) k_4_pressed = true;
                            k_4_held = true;
                            _k_4_allowed = false;
                            break;
                        case SDLK_5:
                            if (_k_5_allowed) k_5_pressed = true;
                            k_5_held = true;
                            _k_5_allowed = false;
                            break;
                        case SDLK_6:
                            if (_k_6_allowed) k_6_pressed = true;
                            k_6_held = true;
                            _k_6_allowed = false;
                            break;
                        case SDLK_7:
                            if (_k_7_allowed) k_7_pressed = true;
                            k_7_held = true;
                            _k_7_allowed = false;
                            break;
                        case SDLK_8:
                            if (_k_8_allowed) k_8_pressed = true;
                            k_8_held = true;
                            _k_8_allowed = false;
                            break;
                        case SDLK_9:
                            if (_k_9_allowed) k_9_pressed = true;
                            k_9_held = true;
                            _k_9_allowed = false;
                            break;

                        }
                    }
                    else if (ev.type == SDL_KEYUP) {
                        switch (ev.key.keysym.sym) {
                        case SDLK_a:
                            k_a_released = true;
                            k_a_held = false;
                            _k_a_allowed = true;
                            break;

                        case SDLK_b:
                            k_b_released = true;
                            k_b_held = false;
                            _k_b_allowed = true;

                            break;

                        case SDLK_c:
                            k_c_released = true;
                            k_c_held = false;
                            _k_c_allowed = true;

                            break;

                        case SDLK_d:
                            k_d_released = true;
                            k_d_held = false;
                            _k_d_allowed = true;

                            break;

                        case SDLK_e:
                            k_e_released = true;
                            k_e_held = false;
                            _k_e_allowed = true;

                            break;

                        case SDLK_f:
                            k_f_released = true;
                            k_f_held = false;
                            _k_f_allowed = true;

                            break;

                        case SDLK_g:
                            k_g_released = true;
                            k_g_held = false;
                            _k_g_allowed = true;

                            break;

                        case SDLK_h:
                            k_h_released = true;
                            k_h_held = false;
                            _k_h_allowed = true;

                            break;

                        case SDLK_i:
                            k_i_released = true;
                            k_i_held = false;
                            _k_i_allowed = true;

                            break;

                        case SDLK_j:
                            k_j_released = true;
                            k_j_held = false;
                            _k_j_allowed = true;

                            break;

                        case SDLK_k:
                            k_k_released = true;
                            k_k_held = false;
                            _k_k_allowed = true;

                            break;

                        case SDLK_l:
                            k_l_released = true;
                            k_l_held = false;
                            _k_l_allowed = true;

                            break;

                        case SDLK_m:
                            k_m_released = true;
                            k_m_held = false;
                            break;

                        case SDLK_n:
                            k_n_released = true;
                            k_n_held = false;
                            _k_n_allowed = true;

                            break;

                        case SDLK_o:
                            k_o_released = true;
                            k_o_held = false;
                            _k_o_allowed = true;

                            break;

                        case SDLK_p:
                            k_p_released = true;
                            k_p_held = false;
                            _k_p_allowed = true;

                            break;

                        case SDLK_q:
                            k_q_released = true;
                            k_q_held = false;
                            _k_q_allowed = true;

                            break;

                        case SDLK_r:
                            k_r_released = true;
                            k_r_held = false;
                            _k_r_allowed = true;

                            break;

                        case SDLK_s:
                            k_s_released = true;
                            k_s_held = false;
                            _k_s_allowed = true;

                            break;

                        case SDLK_t:
                            k_t_released = true;
                            k_t_held = false;
                            _k_t_allowed = true;

                            break;

                        case SDLK_u:
                            k_u_released = true;
                            k_u_held = false;
                            _k_u_allowed = true;

                            break;

                        case SDLK_v:
                            k_v_released = true;
                            k_v_held = false;
                            _k_v_allowed = true;

                            break;

                        case SDLK_w:
                            k_w_released = true;
                            k_w_held = false;
                            _k_w_allowed = true;

                            break;

                        case SDLK_x:
                            k_x_released = true;
                            k_x_held = false;
                            _k_x_allowed = true;

                            break;

                        case SDLK_y:
                            k_y_released = true;
                            k_y_held = false;
                            _k_y_allowed = true;

                            break;

                        case SDLK_z:
                            k_z_released = true;
                            k_z_held = false;
                            _k_z_allowed = true;

                            break;

                        case SDLK_SPACE:
                            k_space_released = true;
                            k_space_held = false;
                            _k_space_allowed = true;

                            break;

                        case SDLK_RETURN:
                            k_enter_released = true;
                            k_enter_held = false;
                            _k_enter_allowed = true;

                            break;

                        case SDLK_ESCAPE:
                            k_escape_released = true;
                            k_escape_held = false;
                            _k_escape_allowed = true;

                            break;

                        case SDLK_LSHIFT:
                        case SDLK_RSHIFT:
                            k_shift_released = true;
                            k_shift_held = false;
                            _k_shift_allowed = true;

                            break;

                        case SDLK_LCTRL:
                        case SDLK_RCTRL:
                            k_ctrl_released = true;
                            k_ctrl_held = false;
                            _k_ctrl_allowed = true;

                            break;

                        case SDLK_LALT:
                        case SDLK_RALT:
                            k_alt_released = true;
                            k_alt_held = false;
                            _k_alt_allowed = true;

                            break;

                        case SDLK_SEMICOLON:
                            k_semicolon_released = true;
                            k_semicolon_held = false;
                            _k_semicolon_allowed = true;

                            break;

                        case SDLK_PERIOD:
                            k_period_released = true;
                            k_period_held = false;
                            _k_period_allowed = true;

                            break;

                        case SDLK_COMMA:
                            k_comma_released = true;
                            k_comma_held = false;
                            _k_comma_allowed = true;

                            break;

                        case SDLK_SLASH:
                            k_slash_released = true;
                            k_slash_held = false;
                            _k_slash_allowed = true;

                            break;

                        case SDLK_BACKSLASH:
                            k_backslash_released = true;
                            k_backslash_held = false;
                            _k_backslash_allowed = true;

                            break;

                        case SDLK_ASTERISK:
                            k_asterisk_released = true;
                            k_asterisk_held = false;
                            _k_asterisk_allowed = true;

                            break;

                        case SDLK_EQUALS:
                            k_equals_released = true;
                            k_equals_held = false;
                            _k_equals_allowed = true;

                            break;

                        case SDLK_MINUS:
                            k_minus_released = true;
                            k_minus_held = false;
                            _k_minus_allowed = true;

                            break;

                        case SDLK_UP:
                            k_up_released = true;
                            k_up_held = false;
                            _k_up_allowed = true;

                            break;

                        case SDLK_DOWN:
                            k_down_released = true;
                            k_down_held = false;
                            _k_down_allowed = true;

                            break;

                        case SDLK_LEFT:
                            k_left_released = true;
                            k_left_held = false;
                            _k_left_allowed = true;

                            break;

                        case SDLK_RIGHT:
                            k_right_released = true;
                            k_right_held = false;
                            _k_right_allowed = true;

                            break;
                        case SDLK_0:
                            k_0_released = true;
                            k_0_held = false;
                            _k_0_allowed = true;
                            break;
                        case SDLK_1:
                            k_1_released = true;
                            k_1_held = false;
                            _k_1_allowed = true;
                            break;
                        case SDLK_2:
                            k_2_released = true;
                            k_2_held = false;
                            _k_2_allowed = true;
                            break;
                        case SDLK_3:
                            k_3_released = true;
                            k_3_held = false;
                            _k_3_allowed = true;
                            break;
                        case SDLK_4:
                            k_4_released = true;
                            k_4_held = false;
                            _k_4_allowed = true;
                            break;
                        case SDLK_5:
                            k_5_released = true;
                            k_5_held = false;
                            _k_5_allowed = true;
                            break;
                        case SDLK_6:
                            k_6_released = true;
                            k_6_held = false;
                            _k_6_allowed = true;
                            break;
                        case SDLK_7:
                            k_7_released = true;
                            k_7_held = false;
                            _k_7_allowed = true;
                            break;
                        case SDLK_8:
                            k_8_released = true;
                            k_8_held = false;
                            _k_8_allowed = true;
                            break;
                        case SDLK_9:
                            k_9_released = true;
                            k_9_held = false;
                            _k_9_allowed = true;
                            break;
                        }

                    }

                    else events.push_back(ev);
                }
                SDL_GetMouseState(&m_x, &m_y);
            }

            void Clear() {
                SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                SDL_RenderClear(rend);
            }

            SDL_Rect Merge_Rectangles(const SDL_Rect& rect1, const SDL_Rect& rect2) {
                SDL_Rect mergedRect;
                mergedRect.x = min(rect1.x, rect2.x);
                mergedRect.y = min(rect1.y, rect2.y);
                mergedRect.w = max(rect1.x + rect1.w, rect2.x + rect2.w) - mergedRect.x;
                mergedRect.h = max(rect1.y + rect1.h, rect2.y + rect2.h) - mergedRect.y;
                return mergedRect;
            }

            void Cap_FPS(int cap) {
                // Calculate the maximum frame time allowed for the desired FPS
                double maxFT = 1.0 / cap;

                // Get the time at the end of the frame
                double frameEndTime = SDL_GetTicks() / 1000.0;

                // Calculate the time it took to process the current frame
                double frameTime = frameEndTime - lastFrameEndTime;

                // Calculate the delay needed to cap the frame rate (if necessary)
                double delayTime = maxFT - frameTime;

                // Check if delay is needed and perform it
                if (delayTime > 0) {
                    SDL_Delay(static_cast<Uint32>(delayTime * 1000.0)); // Convert to milliseconds
                }

                // Update the time for the end of the next frame
                lastFrameEndTime = SDL_GetTicks() / 1000.0;
            }

            double lastFrameEndTime = 0.0;

            double FPS() {
                static int frameCount = 0;
                static double lastTime = 0.0;
                double currentTime = SDL_GetTicks() / 1000.0;  // Get current time in seconds
                frameCount++;

                if (currentTime - lastTime >= 1.0) {
                    double fps = static_cast<double>(frameCount) / (currentTime - lastTime);
                    lastTime = currentTime;
                    frameCount = 0;
                    lastfps = fps; // Update lastFPS when the calculation is done
                }

                return lastfps; // Return lastFPS, which may be the last calculated FPS or -1.0
            }

            double Get_DT() {
                static double lastTime = SDL_GetTicks() / 1000.0;
                double currentTime = SDL_GetTicks() / 1000.0;
                double deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                return deltaTime;
            }

        };
        
    }

    namespace Physics {


        struct circle {
            circle(double ra) : rad(ra) {}
            double rad;
        };
        struct rect {
            rect(double iw, double ih) : w(iw), h(ih) {}
            double w = 0;
            double h = 0;
        };
        struct polygon {
            polygon(std::vector<b2Vec2> p) : points(p) {}
            std::vector<b2Vec2> points;
        };

        struct dimension {
            double w = 0;
            double h = 0;
            double rad = 0;
            std::vector<b2Vec2> points;
            rect As_Square() {
                return { w,h };
            }
            circle As_Circle() {
                return { rad };
            }
            polygon As_Polygon() {
                return { points };
            }
        };
        struct type {
        public:
            type() {}
            type(std::string _spr = "NULL", rect d = rect(32, 32), b2BodyType _b_type = b2_dynamicBody) {
                
                spr = _spr;
                b_type = _b_type;
                dimension.w = d.w;
                dimension.h = d.h;
                c_type = 2;
                mass = 40;
            }
            type(std::string _spr = "NULL", circle d = circle(40), b2BodyType _b_type = b2_dynamicBody) {
                
                spr = _spr;
                b_type = _b_type;
                dimension.rad = d.rad;
                c_type = 1;
                mass = 40;
            }
            type(std::string _spr = "NULL", polygon d = { {} }, b2BodyType _b_type = b2_dynamicBody) {
                
                spr = _spr;
                b_type = _b_type;
                dimension.points = d.points;
                c_type = 3;
                mass = 40;
            }
            std::string spr = "NULL";
            b2BodyType b_type = b2_dynamicBody;
            int c_type = 2;
            dimension dimension;
            double mass = 40;
            std::vector <b2Vec2> points;
        };
        struct _rc {

            _rc() {}
            _rc(b2World* worl, double _x1, double _y1, bool st, double _x, double _y, b2Body* _b1, b2Body* _b2) {
                x1 = _x1;
                world = worl;
                y1 = _y1;
                b1 = _b1;
                b2 = _b2;
                stop = st;
                x = _x;
                y = _y;
            }
            std::vector<b2Body*> bodies;
            double x1 = 0;
            double x = 0;
            double y1 = 0;
            double y = 0;
            b2Body* b1 = nullptr;
            b2Body* b2 = nullptr;
            double normal = 0;
            bool stop = false;
            float fraction = 0.0;
            b2World* world = nullptr;
            b2RayCastInput inp;
            b2RayCastOutput out;
            b2Vec2 hitPoint;
            bool check() {
                bodies = {};

                b2Vec2 st = b1->GetPosition();
                b2Vec2 en = { static_cast<float32> (x1), static_cast<float32> (y1) };
                b2RayCastInput input;
                inp = input;
                input.p1 = st;
                input.p2 = en;
                input.maxFraction = 1;
                b2RayCastOutput output;
                b2Vec2 inters;
                bool hit = false;
                float closestFraction = 1; //start with end of line as p2
                b2Vec2 intersectionNormal(0, 0);
                for (b2Body* b = world->GetBodyList(); b; b = b->GetNext()) {
                    b2Fixture* fixt = b->GetFixtureList();
                    if (b == b1) continue;
                    bool is = (fixt == b2->GetFixtureList());

                    if (!fixt->RayCast(&output, input, 0)) continue;
                    if (output.fraction < closestFraction) {
                        hit = is;

                        closestFraction = output.fraction;
                        intersectionNormal = output.normal;

                        if (hit) {
                            bodies.push_back(fixt->GetBody());
                        }

                        // Calculate the angle in radians
                        normal = std::atan2(output.normal.y, output.normal.x);

                        // Convert the angle to degrees if needed
                        normal *= 180.0f / b2_pi;
                    }

                }
                fraction = closestFraction;
                b2Vec2 intersectionPoint = st + closestFraction * (en - st);
                hitPoint = intersectionPoint;
                if (!hit && !stop) hitPoint = input.p2;
                return hit;
            }
        };
        struct raycast {
            std::vector<type*> typesHit;
            bool hit = false;
            float normal = 0;
            float dist = 0;
            double x = 0;
            double y = 0;
            double length = 0;
            double angle = 0;
        };
        struct emit {
            emit() {}
            emit(double _force, double _angle, b2Body* _from) : force(_force), angle(_angle), from(_from) {
            
            }
            double force = 0;
            double angle = 0;
            b2Body* from = nullptr;
        };
        struct attach {
            bool isAttached = false;
            b2Body* from;
            double offsetX = 0;
            double offsetY = 0;
            bool match_angle = false;
        };

        class Obj {
        public:

            // Constructors and Initialization
            Obj() {
            }
            Obj(type* t, b2World* _world, double _x, double _y, emit* emit = nullptr) {
                world = _world;
                double w = t->dimension.w - 1,
                    h = t->dimension.h - 1;
                b_type = t->b_type,
                    mass = t->mass,
                    c_type = t->c_type,
                    smass = mass,
                    Type = t,
                    sprite = t->spr;
                em = emit;
                switch (c_type) {
                case CIRCLE_SHAPE:
                    Define_Circle(_x, _y, w / 2, (M_PI * w * w) / mass, b_type);
                    break;
                case RECT_SHAPE:
                    Define_Box(_x, _y, w, h, w * h / mass, b_type);
                    break;
                case POLYGON_SHAPE:
                    Define_Polygon(_x, _y, t->points, w * h / mass, b_type);
                }
                Set_Pos(_x, _y);

                if (att.isAttached) {
                    body->SetActive(false);
                    Set_Pos(att.from->GetWorldCenter().x * 32 + att.offsetX, att.from->GetWorldCenter().y * -32 + att.offsetX);
                    if (att.match_angle) Set_Angle(body->GetAngle() * (180 / M_PI));
                }
                if (em != nullptr) {
                    Angular_Impulse(em->force * 100, em->angle);
                    b2Vec2 p = { em->from->GetWorldCenter().x * 32, em->from->GetWorldCenter().y * -32 };

                    if (!emHasCollided) {
                        raycast r = RayCast(
                            p,
                            em->from,
                            false,
                            false
                        );
                        emHasCollided = (r.hit && r.dist >= 5);
                    }
                    Set_Solid(emHasCollided);
                    body->SetUserData(this);

                }
                
            }

            // constructor as a function
            void define(type* t, b2World* _world, double _x, double _y) {
                world = _world;
                double w = t->dimension.w - 1,
                    h = t->dimension.h - 1;
                b_type = t->b_type,
                    mass = t->mass,
                    c_type = t->c_type,
                    smass = mass,
                    Type = t,
                    sprite = t->spr;

                switch (c_type) {
                case CIRCLE_SHAPE:
                    Define_Circle(_x, _y, w / 2, (M_PI * w * w) / mass, b_type);
                    break;
                case RECT_SHAPE:
                    Define_Box(_x, _y, w, h, w * h / mass, b_type);
                    break;
                case POLYGON_SHAPE:
                    Define_Polygon(_x, _y, t->points, w * h / mass, b_type);
                }
                Set_Pos(_x, _y);

                if (att.isAttached) {
                    body->SetActive(false);
                    Set_Pos(att.from->GetWorldCenter().x * 32 + att.offsetX, att.from->GetWorldCenter().y * -32 + att.offsetX);
                    if (att.match_angle) Set_Angle(body->GetAngle() * (180 / M_PI));
                }
                if (em != nullptr) {
                    Angular_Impulse(em->force * 100, em->angle);
                    b2Vec2 p = { em->from->GetWorldCenter().x * 32, em->from->GetWorldCenter().y * -32 };

                    if (!emHasCollided) {

                        raycast r = RayCast(
                            p,
                            em->from,
                            false,
                            false
                        );
                        emHasCollided = (r.hit && r.dist >= 5);
                    }
                    Set_Solid(emHasCollided);
                }
                body->SetUserData(this);

            }
            
            // Member Variables
            type* Type = nullptr;
            int c_type = 0;
            bool DoGravity = true;
            bool DoRotation = false;
            bool SleepWhenOutOfView = false;
            int ViewBufferPixels = 100;

            float mass = 10;
            double xVel = 0;
            double yVel = 0;
            int DisplayOrder = 99999;
            SDL_RendererFlip flip = SDL_FLIP_NONE;

            std::unordered_map<b2Body*, bool> col_body;
            std::unordered_map<type*, bool> col_type;

            // Box2D Physics Members
            b2Body* body = nullptr;
            SDL_Renderer* rend = nullptr;

            // animations and drawing
            std::string sprite = "NULL";
            animation* anim = nullptr;

            // Getter for Angle
            double Get_Angle() {
                return body->GetAngle();
            }

            // Setter for Angle
            double Set_Angle(double angl) {
                body->SetTransform(body->GetPosition(), angl * (M_PI / 180) * (-1));
                return angl;
            }

            void Set_Dimensions(double nw, double nh) {
                if (Type->c_type == POLYGON_SHAPE || Type->c_type == RECT_SHAPE) {
                    double wm = nw / Get_Dimensions().w;
                    double hm = nh / Get_Dimensions().h;
                    std::vector<b2Vec2> po;
                    b2PolygonShape* sh = static_cast<b2PolygonShape*> (body->GetFixtureList()->GetShape());
                    for (int i = 0; i < sh->GetVertexCount(); i++) {
                        b2Vec2 v = sh->GetVertex(i);
                        po.push_back(b2Vec2(v.x * wm, v.y * hm));
                    }
                    sh->Set(po.data(), po.size());
                }
                else static_cast<b2CircleShape*> (body->GetFixtureList()->GetShape())->m_radius = nw / 32;
                
            }

            dimension Get_Dimensions() {
                dimension out;
                
                if (Type->c_type != CIRCLE_SHAPE) {
                    double sx = 9999999999;
                    double sy = 9999999999;
                    double bx = -9999999999;
                    double by = -9999999999;

                    b2PolygonShape* sh = static_cast<b2PolygonShape*>(body->GetFixtureList()->GetShape());

                    // Initialize min and max values with the first vertex
                    b2Vec2 firstVertex = sh->GetVertex(0);
                    sx = firstVertex.x * 32;
                    sy = firstVertex.y * 32;
                    bx = sx;
                    by = sy;

                    for (int i = 1; i < sh->GetVertexCount(); i++) {
                        b2Vec2 v = sh->GetVertex(i);
                        sx = min(sx, v.x * 32);
                        sy = min(sy, v.y * 32);
                        bx = max(bx, v.x * 32);
                        by = max(by, v.y * 32);
                    }
                    
                    out.w = abs((bx) - (sx));
                    out.h = abs((by)-(sy));
                    return out;
                }

                else out.rad = static_cast<b2CircleShape*> (body->GetFixtureList()->GetShape())->m_radius * -32;

                return out;
                }


            // Set Renderer and Camera
            void Set_Renderer(SDL_Renderer* renderer, camera* camera) {
                rend = renderer;
                cam = camera;
            }

            // jump
            void Impulse(double x, double y) {
                body->ApplyLinearImpulseToCenter({ static_cast<float32>(x / 5), static_cast<float32>(-y / 5) }, true);
            }

            // jump at angle
            void Angular_Impulse(double force, double angle) {
                float radians = angle * (M_PI / 180.0f);

                // Calculate the X and Y components of the force vector
                float forceX = force * cos(radians);
                float forceY = force * sin(radians);

                // Apply the force to the body
                b2Vec2 forceVector(forceX, forceY);
                body->ApplyLinearImpulseToCenter({ static_cast<float32>(forceX / 5), static_cast<float32>(-forceY / 5) }, true);
            }

            // easier velocity setting
            void velocity(std::vector<bool> keys, double vel) {
                vel += 1;
                if (keys[0]) yVel = -vel; // Move up (negative y velocity)
                if (keys[1]) xVel = -vel; // Move left (negative x velocity)
                if (keys[2]) yVel = vel; // Move down (positive y velocity)
                if (keys[3]) xVel = vel; // Move right (positive x velocity) 
                if (!keys[0] and !keys[2]) yVel = 0; // Stop vertical movement when both W and S are released
                if (!keys[1] and !keys[3]) xVel = 0; // Stop horizontal movement when both A and D are released
            }

            // get velocity at an angle
            void Angular_Velocity(double angle, double vel) {
                float radians = angle * (M_PI / 180.0f) * (-1);

                // Calculate the X and Y components of the force vector
                float forceX = vel * cos(radians);
                float forceY = vel * sin(radians);

                // Apply the force to the body
                b2Vec2 forceVector(forceX, forceY);
                b2Vec2 v = { static_cast<float32>(forceX / 5), static_cast<float32>(-forceY / 5) };
                xVel = v.x, yVel = v.y;
            }

            // get the points of the shape
            std::vector<b2Vec2> Get_Shape_Points() {
                if (Type->c_type == CIRCLE_SHAPE) return {};
                std::vector<b2Vec2> out;
                b2Shape* sh = body->GetFixtureList()->GetShape();
                b2PolygonShape* shape;
                if (!sh->e_circle) {
                    shape = static_cast<b2PolygonShape*> (sh);
                }
                for (int i = 0; i < shape->GetVertexCount(); i++) {
                    out.push_back({ static_cast<float32> (shape->GetVertex(i).x * 32), static_cast<float32> (shape->GetVertex(i).y * -32) });

                }
                return out;
            }

            // Perform a Raycast and optionally draw it
            raycast RayCast(double dist, double angle, Obj* to, bool stop, bool Draw, SDL_Color color = ORANGE) {
                raycast out;

                b2Vec2 s = AngleAndDistance_To(Get_Center().x, Get_Center().y, angle, dist);
                if (Type->c_type == CIRCLE_SHAPE) s = AngleAndDistance_To(Get_Pos().x, Get_Pos().y, angle, dist);

                out.x = s.x;
                out.y = s.y;
                out.angle = angle;
                out.length = dist;
                _rc rc = {
                    world,
                    s.x / 32,
                    s.y / -32,
                    stop,
                    body->GetWorldCenter().x,
                    body->GetWorldCenter().y,
                    body,
                    to->body,
                };
                out.hit = rc.check();
                out.dist = dist * rc.fraction;
                out.x = rc.hitPoint.x;
                out.y = rc.hitPoint.y;
                out.normal = rc.normal;

                for (b2Body* i : rc.bodies) {
                    out.typesHit.push_back(static_cast<Obj*> (i->GetUserData())->Type);
                }

                // Display ray if requested
                if (Draw) {
                    if (rend != nullptr && cam != nullptr) {
                        SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                        SDL_RenderDrawLine(rend, Get_Pos().x - cam->x, Get_Pos().y - cam->y, rc.hitPoint.x * 32 - cam->x, rc.hitPoint.y * -32 - cam->y);

                    }
                    else {
                        std::cerr << "renderer is not defined. Use Set_Renderer() to set your renderer (Window.rend)." << "\n";
                    }
                }
                return out;
            }
            raycast RayCast(double dist, double angle, b2Body* to, bool stop, bool Draw, SDL_Color color = ORANGE) {
                raycast out;

                b2Vec2 s = AngleAndDistance_To(Get_Center().x, Get_Center().y, angle, dist);
                if (Type->c_type == CIRCLE_SHAPE) s = AngleAndDistance_To(Get_Pos().x, Get_Pos().y, angle, dist);

                out.x = s.x;
                out.y = s.y;
                out.angle = angle;
                out.length = dist;
                _rc rc = {
                    world,
                    s.x / 32,
                    s.y / -32,
                    stop,
                    body->GetWorldCenter().x,
                    body->GetWorldCenter().y,
                    body,
                    to,
                };
                out.hit = rc.check();
                out.dist = dist * rc.fraction;
                out.x = rc.hitPoint.x;
                out.y = rc.hitPoint.y;
                out.normal = rc.normal;

                for (b2Body* i : rc.bodies) {
                    out.typesHit.push_back(static_cast<Obj*> (i->GetUserData())->Type);
                }

                // Display ray if requested
                if (Draw) {
                    if (rend != nullptr && cam != nullptr) {
                        SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                        SDL_RenderDrawLine(rend, Get_Pos().x - cam->x, Get_Pos().y - cam->y, rc.hitPoint.x * 32 - cam->x, rc.hitPoint.y * -32 - cam->y);

                    }
                    else {
                        std::cerr << "renderer is not defined. Use Set_Renderer() to set your renderer (Window.rend)." << "\n";
                    }
                }
                return out;
            }
            raycast RayCast(b2Vec2 s, Obj* to, bool stop, bool Draw, SDL_Color color = ORANGE) {
                
                double angle = Angle_To(Get_Center().x, Get_Center().y, s.x, s.y);
                double length = Distance_To(Get_Center().x, Get_Center().y, s.x, s.y);
                if (Type->c_type == CIRCLE_SHAPE) length = Distance_To(Get_Pos().x, Get_Pos().y, s.x, s.y);
                return RayCast(length, angle, to, stop, Draw, color);
            }
            raycast RayCast(b2Vec2 s, b2Body* to, bool stop, bool Draw, SDL_Color color = ORANGE) {

                double angle = Angle_To(Get_Center().x, Get_Center().y, s.x, s.y);
                double length = Distance_To(Get_Center().x, Get_Center().y, s.x, s.y);
                if (Type->c_type == CIRCLE_SHAPE) length = Distance_To(Get_Pos().x, Get_Pos().y, s.x, s.y);
                return RayCast(length, angle, to, stop, Draw, color);
            }

            // Detect objects in proximity and optionally draw them
            bool proximity(Obj* to, double rad, bool draw = false, int density = 10, SDL_Color color = BLACK) {
                bool out = false;

                b2Vec2 last = AngleAndDistance_To(body->GetWorldCenter().x * 32 - cam->x, body->GetWorldCenter().y * -32 - cam->y, 0, rad);
                b2Vec2 first = last;
                for (int angle = 0; angle <= 360; angle += density) {
                    raycast r = RayCast(rad, angle, to, false, false);

                    if (r.hit) out = true;

                    b2Vec2 point = AngleAndDistance_To(body->GetWorldCenter().x * 32 - cam->x, body->GetWorldCenter().y * -32 - cam->y, angle, rad);
                    SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                    if (draw) SDL_RenderDrawLine(rend, last.x, last.y, point.x, point.y);
                    last = point;
                }
                return out;
            }
            bool proximity(b2Body* to, double rad, bool draw = false, int density = 10, SDL_Color color = BLACK) {
                bool out = false;

                b2Vec2 last = AngleAndDistance_To(body->GetWorldCenter().x * 32 - cam->x, body->GetWorldCenter().y * -32 - cam->y, 0, rad);
                b2Vec2 first = last;
                for (int angle = 0; angle <= 360; angle += density) {
                    raycast r = RayCast(rad, angle, to, false, false);

                    if (r.hit) out = true;

                    b2Vec2 point = AngleAndDistance_To(body->GetWorldCenter().x * 32 - cam->x, body->GetWorldCenter().y * -32 - cam->y, angle, rad);
                    SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                    if (draw) SDL_RenderDrawLine(rend, last.x, last.y, point.x, point.y);
                    last = point;
                }
                return out;
            }

            b2Vec2 Set_Camera(camera* cam) {
                cam->x = Get_Center().x - cam->wW / 2;
                cam->y = Get_Center().y - cam->wH / 2;
                if (Type->c_type == CIRCLE_SHAPE) {
                    cam->x = Get_Pos().x - cam->wW / 2;
                    cam->y = Get_Pos().y - cam->wH / 2;
                }
                return { static_cast<float32> (cam->x),  static_cast<float32> (cam->y) };

            }

            bool operator==(const Obj b) {
                return (body == b.body);
            }

            b2Vec2 Get_Pos() {
                // Get position
                float32 x = body->GetPosition().x - Get_Dimensions().w / 64;
                float32 y = -body->GetPosition().y - Get_Dimensions().h / 64;
                if (Type->c_type == CIRCLE_SHAPE) {
                    x = body->GetPosition().x;
                    y = -body->GetPosition().y;
                }
                x *= 32;
                y *= 32;
                return { x,y };

            }
            b2Vec2 Get_Center() {
                return { body->GetWorldCenter().x * 32, body->GetWorldCenter().y * -32 };
            }
            
            void Set_Pos(double x, double y) {
                body->SetTransform({ static_cast<float32> (x / 32 - Get_Dimensions().w / 64), static_cast<float32> (y / -32 - Get_Dimensions().h / -64) }, Get_Angle());
            }
            void Set_Pos(b2Vec2 p) {
                body->SetTransform(p, Get_Angle());
            }

            void Set_Center(float32 x, float32 y) {
                Set_Pos(x - Get_Dimensions().w / 2, y - Get_Dimensions().h / 2);
            }
            void Set_Center(b2Vec2 p) {
                Set_Pos(p);
            }
            void Set_Solid(bool is) {
                body->GetFixtureList()->SetSensor(!is);
            }

            bool Get_Solid() {
                return !body->GetFixtureList()->IsSensor();
            }

            // Update Object
            virtual void Update() {
                if (hasBody != false) {
                    if (function != nullptr) function();

                    if (em != nullptr) {
                        b2Vec2 p = { em->from->GetWorldCenter().x * 32, em->from->GetWorldCenter().y * -32 };
                     if (!emHasCollided) {
                        raycast r = RayCast(
                            p,
                            em->from,
                            false,
                            false
                        );
                        emHasCollided = (r.hit && r.dist >= 5);
                    }
                        Set_Solid(emHasCollided);
                    }

                    // Set gravity and rotation
                    body->SetGravityScale(DoGravity);
                    if (DoRotation) body->SetFixedRotation(false);
                    else body->SetFixedRotation(true);

                    if (GetCollisions) {
                        // Get contact list (collisions)
                        b2ContactEdge* c = body->GetContactList();

                        // Get collision list
                        int iterations = 0;
                        while (c) {
                            auto contact = c->contact;
                            auto fixtureB = contact->GetFixtureB();
                            Obj* b = static_cast<Obj*> (fixtureB->GetBody()->GetUserData());
                            col_body[fixtureB->GetBody()] = contact->IsTouching();
                            col_type[b->Type] = contact->IsTouching();

                            c = c->next;
                            iterations += 1;
                        }
                    }
                        if (att.isAttached) {
                            Set_Pos(att.from->GetWorldCenter().x * 32 + att.offsetX, att.from->GetWorldCenter().y * -32 + att.offsetX);
                            if (att.match_angle) Set_Angle(static_cast<Obj*> (att.from->GetUserData())->Get_Angle() * (180 / M_PI) * (-1));
                            body->DestroyFixture(body->GetFixtureList());
                        }
                    
                    // Get velocity
                    _Velocity();
                    body->SetUserData(this);
                }
            }

            void Destroy() {
                if (body == nullptr) return;
                world->DestroyBody(body);
                body = nullptr;
                hasBody = false;
            }

            attach att;
            emit* em = nullptr;

            void (*function)();

            b2World* world = nullptr;

            bool hasBody = true;

            bool GetCollisions = false;

        private:
            
            int id;
            double smass = 0;
            b2BodyType b_type = b2_dynamicBody;
            int ct = 0;
            camera* cam;
            double impY = 0;
            double impX = 0;
            bool emHasCollided = false;
            // Define Circle and square Fixture
            void Define_Circle(double x, double y, double rad, double dens, b2BodyType type) {
                b2BodyDef bodydef;
                bodydef.type = type;
                bodydef.position.Set(x, -y);
                b2FixtureDef fxtdef;
                body = world->CreateBody(&bodydef);
                
                b2CircleShape Dshape;
                Dshape.m_p.Set(-1, 1);
                Dshape.m_radius = Type->dimension.rad / 64;
                fxtdef.shape = &Dshape;
                fxtdef.density = dens;
                body->CreateFixture(&fxtdef);
            }
            void Define_Box(double x, double y, double _W, double _H, double dens, b2BodyType type) {
                b2BodyDef bodydef;
                bodydef.type = type;
                bodydef.position.Set(x, -y);
                b2FixtureDef fxtdef;
                body = world->CreateBody(&bodydef);

                b2PolygonShape Dshape;
                Dshape.SetAsBox(_W / 64, _H / 64);
                fxtdef.shape = &Dshape;
                fxtdef.density = dens;
                body->CreateFixture(&fxtdef);

            }
            void Define_Polygon(double x, double y, std::vector <b2Vec2> points, double dens, b2BodyType type) {

                for (int i = 0; i < points.size(); i++) {
                    points[i].x /= 32;
                    points[i].y /= 32;
                }
                b2BodyDef bodydef;
                bodydef.type = type;
                bodydef.position.Set(x, -y);
                b2FixtureDef fxtdef;
                body = world->CreateBody(&bodydef);

                b2PolygonShape Dshape;

                Dshape.Set(points.data(), points.size());
                fxtdef.shape = &Dshape;
                fxtdef.density = dens;
                if (body == nullptr) std::cout << "dead";
                body->CreateFixture(&fxtdef);
            }


            void _Velocity() {
                b2Vec2 desiredVel = b2Vec2(xVel, -yVel);

                b2Vec2 currentVel = body->GetLinearVelocity();
                b2Vec2 velChange(desiredVel.x - currentVel.x, desiredVel.y - currentVel.y);
                float forceX = body->GetMass() * velChange.x;
                float forceY = body->GetMass() * velChange.y;
                // Apply the forces to the body
                body->ApplyForceToCenter(b2Vec2(forceX, forceY), true);


            }

            void ApplyAngularVelocity(float force, double angle) {
                float radians = angle * (M_PI / 180.0f);

                // Calculate the X and Y components of the force vector
                float forceX = force * cos(radians);
                float forceY = force * sin(radians);
                // Apply the force to the body
                b2Vec2 forceVector(forceX, forceY);
                body->ApplyLinearImpulseToCenter(forceVector, true);
            }

        };

        class Window : public No_Physics::Window {
        public:

            // arguments:
            // name: the window name
            // width: the window width
            // height: the window height
            // flags: the window flags, (SHOWN, RESIZABLE, etc)
            Window(std::string _name, int _W, int _H, Uint32 flags = SHOWN) : No_Physics::Window(_name, _W, _H, flags) {
                b2Vec2 grav = { 0, -9.81 };
                world = new b2World(grav);
            
            }
            
            //  update the window, and its values
            bool Run()  {
                
                // pause or update the game world
                if (!paused) world->Step(dt + 0.02, 6, 2);
                // draw bodies
                for (b2Body* i = world->GetBodyList(); i; i = i->GetNext()) {
                    Obj* o = reinterpret_cast<Obj*> (i->GetUserData());
                    if (o->body == nullptr) continue;
                    o->body->SetActive(!o->SleepWhenOutOfView && !inView(o, o->ViewBufferPixels));

                    if (!paused) {
                        o->Update();
                        o->Obj::Update();
                    }

                    if (o->sprite != "NULL" && o->body != nullptr) {
                        if (o->c_type != CIRCLE_SHAPE) {
                            if (o->anim == nullptr) Draw_Sprite(ceil(o->Get_Pos().x) + 32, ceil(o->Get_Pos().y) + 32, o->Get_Dimensions().w, o->Get_Dimensions().h, o->Get_Angle() * (180 / M_PI), o->sprite, { 10,10,9,9 }, GAME_LAYER, o->DisplayOrder, o->flip);
                            else Draw_Animation(ceil(o->Get_Pos().x), ceil(o->Get_Pos().y), o->Get_Dimensions().w, o->Get_Dimensions().h, o->Get_Angle() * (180 / M_PI), o->anim, o->DisplayOrder, GAME_LAYER, o->flip);
                        }
                        else {
                            if (o->anim == nullptr) Draw_Sprite(o->Get_Pos().x + o->Get_Dimensions().rad, o->Get_Pos().y + o->Get_Dimensions().rad, -o->Get_Dimensions().rad * 2, -o->Get_Dimensions().rad * 2, o->Get_Angle() * (180 / M_PI), "player.bmp");
                            else Draw_Animation(o->Get_Pos().x + o->Get_Dimensions().rad, o->Get_Pos().y + o->Get_Dimensions().rad, -o->Get_Dimensions().rad * 2, -o->Get_Dimensions().rad * 2, o->Get_Angle() * (180 / M_PI), o->anim, o->DisplayOrder, GAME_LAYER, o->flip);

                        }
                        }
                
                }
                No_Physics::Window::Run();

                Update();
                return running;
            }
            virtual void Update() override {}
            
            // if the physics world is paused
            bool paused = false;

            // the physics world
            b2World* world = nullptr;

            // set the game gravity
            void Set_Gravity(float32 hor, float32 vert) {
                world->SetGravity({ hor, vert * (-1) });
            }

            // check if an object is inside the window
            bool inView(Obj* o, int viewBufferPixels = 0) {
                for (b2Vec2 i : o->Get_Shape_Points()) {
                    return (i.x > W + viewBufferPixels || i.x < 0 - viewBufferPixels || i.y > H + viewBufferPixels || i.y < 0 - viewBufferPixels);
                }
            }

            // spawn an object. arguments:
            
            // - the object type
            
            // - the object positions

            Obj* Spawn(type* t, double _x, double _y) {
                Obj* object = new Obj(t, world, _x + t->dimension.w / 2, _y + t->dimension.h / 2);
                object->body->SetUserData(object);
                object->Set_Renderer(rend, &cam);

                return object;
            }

            Obj* Emit(type* t, Obj* f, double force, double angle) {
                Obj* o = new Obj(t, world, f->Get_Center().x, f->Get_Center().y, new emit(force, angle, f->body));
                o->Set_Renderer(rend, &cam);
                o->body->SetUserData(o);
                
                return o;
            }

            Obj* Attach(Obj* from, type* t, double offsetX = 0, double offsetY = 0, bool match_angle = false) {
                Obj* object = new Obj(t, world, 0 + t->dimension.w / 2, 0 + t->dimension.h / 2);
                object->att.isAttached = true;
                object->att.offsetX = offsetX;
                object->att.offsetY = offsetY;
                object->att.match_angle = match_angle;
                object->att.from = from->body;

                object->body->SetUserData(object);
                object->Set_Renderer(rend, &cam);

                return object;
            }

            // get a Physics::Obj from a b2Body*
            Obj* Get_Obj_From_Body(b2Body* Body) {
                return reinterpret_cast<Obj*>(Body->GetUserData());
            }

        };
    }

    

    //------------------------
    //       functions       | 
    //------------------------

    // blend two colors together. add a factor as a third argument, and the closer it is to 0, the closer the color is to color 1, factor can only be from 0 to 1
    SDL_Color Blend_color(const SDL_Color color1, const SDL_Color color2, float factor = 0.5f, int alpha = 0) {
        // Ensure the factor is within the range [0, 1]
        factor = (factor > 1.0f ? 1.0f : (factor < 0.0f ? 0.0f : factor));

        // Calculate the blended color component-wise
        Uint8 r = static_cast<Uint8>((1.0f - factor) * color1.r + factor * color2.r);
        Uint8 g = static_cast<Uint8>((1.0f - factor) * color1.g + factor * color2.g);
        Uint8 b = static_cast<Uint8>((1.0f - factor) * color1.b + factor * color2.b);
        Uint8 a = static_cast<Uint8>((1.0f - factor) * color1.a + factor * color2.a);

        SDL_Color blendedColor = { r, g, b, (alpha == 0 ? a : alpha) };
        return blendedColor;
    }

    // play sound
    void Play_Sound(std::string file) {
        // Build the mciSendString command to open and play the sound file
        std::string command = "open \"" + file + "\" type mpegvideo alias mySound";
        mciSendStringA(command.c_str(), NULL, 0, NULL);

        // Play the sound
        mciSendStringA("play mySound", NULL, 0, NULL);
    }

    //---------------------
    //         MATH       |
    //---------------------

    float Angle_To(int p1x, int p1y, int p2x, int p2y)
    {
        int deltaY = p2y - p1y;
        int deltaX = p2x - p1x;

        float angleInDegrees = atan2(deltaY, deltaX) * 180 / M_PI;


        return angleInDegrees;
    }
    float Angle_To(b2Vec2 p1, b2Vec2 p2)
    {
        int deltaY = p2.y - p1.y;
        int deltaX = p2.x - p1.x;

        float angleInDegrees = atan2(deltaY, deltaX) * 180 / M_PI;


        return angleInDegrees;
    }

    double Distance_To(int x, int y, int x1, int y1) {
        int a = x1 - x;
        int b = y1 - y;
        int c = sqrt(a * a + b * b);
        return abs(c);
    }
    double Distance_To(b2Vec2 p1, b2Vec2 p2) {
        int a = p2.x - p1.x;
        int b = p2.y - p1.y;
        int c = sqrt(a * a + b * b);
        return abs(c);
    }
    b2Vec2 AngleAndDistance_To(int x, int y, double angle, double distance) {
        // Convert angle from degrees to radians
        double radians = angle * M_PI / 180.0;

        // Calculate the destination coordinates as doubles
        double dx = distance * cos(radians);
        double dy = distance * sin(radians);

        return { static_cast<float32>(dx + x), static_cast<float32>(dy + y) };
    }

    int Random(int num1, int num2) {
        std::random_device dev;
        std::default_random_engine gen{dev()};
        std::uniform_int_distribution<int> dis{num1, num2};
        return dis(gen);
    }

    SDL_Color Random_Color() {
        SDL_Color color = { Random(0,255),Random(0,255),Random(0,255),255 };
        return color;
    }

    //----------------------
    //      save/load      |
    //----------------------

    bool Save(std::string content, const std::string& filename) {
        std::ofstream file(filename);
        if (!file.is_open()) {
            std::cerr << "Error: Unable to open the file for writing." << std::endl;
            return false;
        }

        file << content; // Write content to the file
        file.close();
        return true;
    }
    std::string Load(const std::string& filename) {
        std::string out;
        std::ifstream file(filename);
        if (!file.is_open()) {
            std::cerr << "Error: Unable to open the file for reading." << std::endl;
            return "NULL";
        }

        std::string line;

        while (std::getline(file, line)) {
            out += line + "\n"; // Read each line and append it to the content
        }

        file.close();
        return out;
    }
    bool Clear_File(const std::string& filename) {
        std::ofstream file(filename, std::ios::trunc); // Open the file in truncation mode

        if (!file.is_open()) {
            std::cerr << "Error: Unable to open the file for clearing." << std::endl;
            return false;
        }

        file.close();
        return true;
    }

    //---------------------
    //        other       |
    //---------------------

    double cast(double val, double min, double max) {
        return (val >= max ? max : val <= min ? min : val);
    }

    std::vector<std::vector<SDL_Color>> bmp_To_Vector(std::string Path) {
        SDL_Surface* surface = SDL_LoadBMP(Path.c_str());
        if (!surface) {
            // Handle error
            return {};
        }

        std::vector<std::vector<SDL_Color>> pixelData(surface->h, std::vector<SDL_Color>(surface->w));

        for (int y = 0; y < surface->h; ++y) {
            for (int x = 0; x < surface->w; ++x) {
                Uint32 pixel = *((Uint32*)surface->pixels + y * surface->w + x);
                Uint8 r, g, b, a;
                SDL_GetRGBA(pixel, surface->format, &r, &g, &b, &a);
                pixelData[y][x] = { r, g, b, a };
            }
        }

        SDL_FreeSurface(surface);
        return pixelData;
    }
    char* vector_To_Bmp(const std::vector<std::vector<SDL_Color>>& pixelData, std::string location, std::string name) {
        int width = pixelData[0].size();
        int height = pixelData.size();
        SDL_Surface* surface = SDL_CreateRGBSurface(0, width, height, 32, 0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF);
        if (!surface) {
            SDL_Log("Unable to create surface: %s", SDL_GetError());
            return nullptr;
        }

        for (int y = 0; y < height; ++y) {
            for (int x = 0; x < width; ++x) {
                SDL_Color color = pixelData[y][x];
                Uint32 pixelValue = SDL_MapRGBA(surface->format, color.r, color.g, color.b, color.a);
                *((Uint32*)surface->pixels + y * width + x) = pixelValue;
            }
        }

        std::string fileName = location + name + ".bmp";

        if (SDL_SaveBMP(surface, fileName.c_str()) != 0) {
            SDL_Log("Unable to save BMP: %s", SDL_GetError());
            SDL_FreeSurface(surface);
            return nullptr;
        }

        SDL_FreeSurface(surface);

        // Convert the file name to char* and return
        char* charFileName = new char[fileName.size() + 1];
        strcpy_s(charFileName, fileName.size() + 1, fileName.c_str());
        return charFileName;
    }

    void debug_double(std::string valname, double value, std::string additional = "") {
        std::cout << "\n" + valname + ": ";
        std::cout << value;
        std::cout << additional;
    }
    void debug_string(std::string valname, std::string value, std::string additional = "") {
        std::cout << "\n" + valname + ": ";
        std::cout << value;
        std::cout << additional;
    }
    void debug_bool(std::string valname, bool value, std::string additional = "") {
        std::cout << "\n" + valname + ": ";
        std::cout << (value == true ? "true" : "false");
        std::cout << additional;
    }
    void debug_intV(std::string valname, std::vector<int> list, std::string additional = "") {
        std::cout << "\n" + valname + ": " + "{ ";
        for (int i = 0; i < list.size(); i++) {
            std::cout << list[i] << (i == list.size() - 1 ? " " : ", ");
        }
        std::cout << "}" + additional;
    }
    void debug_floatV(std::string valname, std::vector<float> list, std::string additional = "") {
        std::cout << "\n" + valname + ": " + "{ ";
        for (int i = 0; i < list.size(); i++) {
            std::cout << list[i] << (i == list.size() - 1 ? " " : ", ");
        }
        std::cout << "}" + additional;
    }
    void debug_doubleV(std::string valname, std::vector < double > list, std::string additional = "") {
        std::cout << "\n" + valname + ": " + "{ ";
        for (int i = 0; i < list.size(); i++) {
            std::cout << list[i] << (i == list.size() - 1 ? " " : ", ");
        }
        std::cout << "}" + additional;
    }
    void debug_boolV(std::string valname, std::vector<bool> list, std::string additional = "") {
        std::cout << "\n" + valname + ": " + "{ ";
        for (int i = 0; i < list.size(); i++) {
            std::cout << (list[i] == true ? "true" : "false") << (i == list.size() - 1 ? " " : ", ");
        }
        std::cout << "}" + additional;
    }
    void debug_stringV(std::string valname, std::vector<std::string> list, std::string additional = "") {
        std::cout << "\n" + valname + ": " + "{ ";
        for (int i = 0; i < list.size(); i++) {
            std::cout << list[i] << (i == list.size() - 1 ? " " : ", ");
        }
        std::cout << "}" + additional;
    }
}
