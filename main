#pragma once

//------------------------
//        headers        |
//------------------------
// SDL
#include <SDL.h>
#include <SDL_ttf.h>
// Box2D
#include <Box2D.h>
//math
#include <cmath>
// vector string and I/O
#include <vector>
#include <unordered_map>
#include <string>
#include <iostream>
#include <fstream>
// random 
#include <random>
// time
#include <chrono>
// windows.h
#if __WIN32__
#include <windows.h>
#pragma comment(lib, "Winmm.lib")
#endif

void emptyFunction() {

}
namespace ogf {
    // predefine functions
    float Angle_To(int p1x, int p1y, int p2x, int p2y);
    double Distance_To(int x, int y, int x1, int y1);
    double Distance_To(b2Vec2 p1, b2Vec2 p2);
    b2Vec2 AngleAndDistance_To(int x, int y, double angle, double distance);

    //------------------------
    //        colors         |
    //------------------------

    // Define commonly used colors
#define RED { 255, 0, 0, 255 }
#define GREEN { 0, 255, 0, 255 }
#define BLUE { 0, 0, 255, 255 }
#define BLACK { 0, 0, 0, 255 }
#define WHITE { 255, 255, 255, 255 }
#define YELLOW { 255, 255, 0, 255 }
#define CYAN { 0, 255, 255, 255 }
#define MAGENTA { 255, 0, 255, 255 }
#define ORANGE { 255, 165, 0, 255 }
#define PURPLE { 128, 0, 128, 255 }
#define PINK { 255, 192, 203, 255 }
#define LIME { 0, 255, 0, 255 }
#define BROWN { 139, 69, 19, 255 }
#define GRAY { 128, 128, 128, 255 }
#define LIGHT_GRAY { 192, 192, 192, 255 }
#define DARK_GRAY { 64, 64, 64, 255 }
#define SILVER { 192, 192, 192, 255 }
#define GOLD { 255, 215, 0, 255 }
#define BEIGE { 245, 245, 220, 255 }
#define INDIGO { 75, 0, 130, 255 }
#define VIOLET { 148, 0, 211, 255 }
#define MAROON { 128, 0, 0, 255 }
#define NAVY { 0, 0, 128, 255 }
#define TEAL { 0, 128, 128, 255 }
#define OLIVE { 128, 128, 0, 255 }
#define SKY_BLUE { 135, 206, 235, 255 }
#define DARK_RED { 139, 0, 0, 255 }
#define DARK_GREEN { 0, 100, 0, 255 }
#define DARK_BLUE { 0, 0, 139, 255 }
#define CYBER_YELLOW { 255, 255, 0, 128 }
#define TURQUOISE { 64, 224, 208, 255 }
#define SALMON { 250, 128, 114, 255 }
#define CORAL { 255, 127, 80, 255 }
#define LAVENDER { 230, 230, 250, 255 }
#define CHOCOLATE { 210, 105, 30, 255 }
#define TOMATO { 255, 99, 71, 255 }
#define PLUM { 221, 160, 221, 255 }
#define GOLDENROD { 218, 165, 32, 255 }
#define PERU { 205, 133, 63, 255 }
#define DARK_ORCHID { 153, 50, 204, 255 }
#define SPRING_GREEN { 0, 255, 127, 255 }
#define CRIMSON { 220, 20, 60, 255 }
#define FIREBRICK { 178, 34, 34, 255 }
#define PALE_GREEN { 152, 251, 152, 255 }
#define DARK_SLATE_GRAY { 47, 79, 79, 255 }
#define MEDIUM_AQUAMARINE { 102, 205, 170, 255 }

// define other stuff

    //earth gravity
#define EARTH_GRAVITY {0,9.81}
    // game layers
    enum Layer {
        BG_LAYER = 1,
        GAME_LAYER = 2,
        UI_LAYER  = 3,
    };
    enum Obj_Shape {
        CIRCLE_SHAPE = 1,
        RECT_SHAPE = 2,
        POLYGON_SHAPE = 3,
    };

    // pi
#ifndef M_PI
#define M_PI = 3.14159265358979323846
#endif

    #define SHOWN SDL_WINDOW_SHOWN // you can see the window.
    #define HIDDEN SDL_WINDOW_HIDDEN // you can't see the window
    #define FULLSCREEN SDL_WINDOW_FULLSCREEN // the window is fullscreen at start
    #define OPENGL SDL_WINDOW_OPENGL // define a window that supports openGL
    #define BORDERLESS SDL_WINDOW_BORDERLESS // define a window that does not have a border
    #define RESIZABLE SDL_WINDOW_RESIZABLE // Create a resizable window.
    #define MINIMIZED SDL_WINDOW_MINIMIZED // Create a minimized window.
    #define MAXIMIZED SDL_WINDOW_MAXIMIZED // Create a maximized window.
    #define INPUT_GRABBED SDL_WINDOW_INPUT_GRABBED // Window has grabbed input focus.
    #define INPUT_FOCUS SDL_WINDOW_INPUT_FOCUS // Window has input focus.
    #define MOUSE_FOCUS SDL_WINDOW_MOUSE_FOCUS // Window has mouse focus.

    enum OS {
        WINDOWS = 0,
        LINUX = 1,
        MAC = 2,
        ANDROID = 3,
        IOS = 4,
        OTHER = 5,
    };

    OS Get_OS() {
#ifdef _WIN32
        return WINDOWS;
#elif __linux__
        return LINUX;
#elif __APPLE__ && __MACH__
        return MAC;
#elif __ANDROID__
        return ANDROID;
#elif __APPLE__
        return IOS;
#else
        return OTHER;
#endif
    }

    //------------------------
    //        classes        |
    // -----------------------

    // a button, made for ease of use
    struct button {
        int x;
        int y;
        int w;
        int h;
        bool pressed = false;
        button() {}
        button(int _x, int _y, int _w, int _h) {
            x = _x;
            y = _y;
            w = _w;
            h = _h;
        }
        void press(int mx, int my, bool clicking) {
            pressed = (mx > x and mx < x + w and my > y and my < y + h) && clicking;
        }
    };
    // ease.
    class Ease {
    private:
        double time;
        double from;
        double to;
        int mode;
        double TimeAtStart;

    public:

        Ease(double atime, double afrom, double ato, int amode) {
            time = atime;
            from = afrom;
            to = ato;
            mode = amode;
            reset();
        }
        double elapsed;
        bool done = false;

        double Get_Ease() {
            elapsed = (SDL_GetTicks() - TimeAtStart) / 1000;
            if (time <= 0.0) {
                std::cerr << "Error: Total duration must be greater than zero." << std::endl;
                return 0.0;
            }

            // Ensure elapsedTime is within the valid range [0, totalDuration]
            elapsed = ((elapsed < time ? elapsed : time) < 0.0 ? 0.0 : (elapsed < time ? elapsed : time));
            if (elapsed == time) done = true;

            // Calculate A as a percentage of elapsed time over total duration
            double A = (elapsed / time) * 100.0;
            double B = from;
            double C = to;
            int D = mode;
            switch (D - 1) {
            case 0:
                return (((C - B) / 100) * A) + B;
            case 1:
                return B + ((SineIn(A)) * (C - B));
            case 2:
                return B + (SineOut(A) * (C - B));
            case 3:
                return B + ((SineInOut(A)) * (C - B));
            case 4:
                return B + (CubicIn(A) * (C - B));
            case 5:
                return B + (CubicOut(A) * (C - B));
            case 6:
                return B + (CubicInOut(A) * (C - B));
            case 7:
                return B + (QuintIn(A) * (C - B));
            case 8:
                return B + (QuintOut(A) * (C - B));
            case 9:
                return B + (QuintInOut(A) * (C - B));
            case 10:
                return B + (CircIn(A) * (C - B));
            case 11:
                return B + (CircOut(A) * (C - B));
            case 12:
                return B + (CircInOut(A) * (C - B));
            case 13:
                return B + (ElasticIn(A) * (C - B));
            case 14:
                return B + (ElasticOut(A) * (C - B));
            case 15:
                return B + (ElasticInOut(A) * (C - B));
            case 16:
                return B + (QuadIn(A) * (C - B));
            case 17:
                return B + (QuadOut(A) * (C - B));
            case 18:
                return B + (QuadInOut(A) * (C - B));
            case 19:
                return B + (QuartIn(A) * (C - B));
            case 20:
                return B + (QuartOut(A) * (C - B));
            case 21:
                return B + (QuartInOut(A) * (C - B));
            case 22:
                return B + (ExpoIn(A) * (C - B));
            case 23:
                return B + (ExpoOut(A) * (C - B));
            case 24:
                return B + (ExpoInOut(A) * (C - B));
            case 25:
                return B + (BackIn(A) * (C - B));
            case 26:
                return B + (BackOut(A) * (C - B));
            case 27:
                return B + (BackInOut(A) * (C - B));
            case 28:
                return B + ((BounceIn(A / 100)) * (C - B));
            case 29:
                return B + ((BounceOut(A / 100)) * (C - B));
            case 30:
                return B + ((BounceInOut(A / 100)) * (C - B));
            default:
                return 0;
            }
            // MADE BY JR01
        }
        void reset() {
            TimeAtStart = SDL_GetTicks();
            done = false;
        }

    private:
        //------------------------
        //        EASES          |
        //------------------------

        double SineIn(double A) {
            return 1 - cos((A / 100) * M_PI / 2);
        }
        double SineOut(double A) {
            return std::sin((A / 100) * M_PI / 2);
        }
        double SineInOut(double A) {
            return -(std::cos(M_PI * (A / 100)) - 1) / 2;
        }
        double CubicIn(double A) {
            return std::pow(A / 100, 3);
        }
        double CubicOut(double A) {
            return 1 - std::pow(1 - A / 100, 3);
        }
        double CubicInOut(double A) {
            return (A / 100) < 0.5 ? 4 * std::pow(A / 100, 3) : 1 - std::pow(-2 * (A / 100) + 2, 3) / 2;
        }
        double QuintIn(double A) {
            return std::pow(A / 100, 5);
        }
        double QuintOut(double A) {
            return 1 - std::pow(1 - A / 100, 5);
        }
        double QuintInOut(double A) {
            return (A / 100) < 0.5 ? 16 * std::pow(A / 100, 5) : 1 - std::pow(-2 * (A / 100) + 2, 5) / 2;
        }
        double CircIn(double A) {
            return 1 - std::sqrt(1 - std::pow(A / 100, 2));
        }
        double CircOut(double A) {
            return std::sqrt(1 - std::pow(A / 100 - 1, 2));
        }
        double CircInOut(double A) {
            return (A / 100) < 0.5 ? (1 - std::sqrt(1 - std::pow(2 * (A / 100), 2))) / 2 : (std::sqrt(1 - std::pow(-2 * (A / 100) + 2, 2)) + 1) / 2;
        }
        double ElasticIn(double A) {
            double c4 = (2 * M_PI) / 3;
            return (A / 100) == 0 ? 0 : (A / 100) == 1 ? 1 : -std::pow(2, 10 * (A / 100) - 10) * std::sin(((A / 100) * 10 - 10.75) * c4);
        }
        double ElasticOut(double A) {
            double c4 = (2 * M_PI) / 3;
            return (A / 100) == 0 ? 0 : (A / 100) == 1 ? 1 : std::pow(2, -10 * (A / 100)) * std::sin(((A / 100) * 10 - 0.75) * c4) + 1;
        }
        double ElasticInOut(double A) {
            double c5 = (2 * M_PI) / 4.5;
            return (A / 100) == 0 ? 0 : (A / 100) == 1 ? 1 : (A / 100) < 0.5 ? -(std::pow(2, 20 * (A / 100) - 10) * std::sin((20 * (A / 100) - 11.125) * c5)) / 2 : (std::pow(2, -20 * (A / 100) + 10) * std::sin((20 * (A / 100) - 11.125) * c5)) / 2 + 1;
        }
        double QuadIn(double A) {
            return std::pow(A / 100, 2);
        }
        double QuadOut(double A) {
            return 1 - (1 - A / 100) * (1 - A / 100);
        }
        double QuadInOut(double A) {
            return (A / 100) < 0.5 ? 2 * std::pow(A / 100, 2) : 1 - std::pow(-2 * (A / 100) + 2, 2) / 2;
        }
        double QuartIn(double A) {
            return std::pow(A / 100, 4);
        }
        double QuartOut(double A) {
            return 1 - std::pow(1 - A / 100, 4);
        }
        double QuartInOut(double A) {
            return (A / 100) < 0.5 ? 8 * std::pow(A / 100, 4) : 1 - std::pow(-2 * (A / 100) + 2, 4) / 2;
        }
        double ExpoIn(double A) {
            return (A / 100) == 0 ? 0 : std::pow(2, 10 * (A / 100) - 10);
        }
        double ExpoOut(double A) {
            return (A / 100) == 1 ? 1 : 1 - std::pow(2, -10 * (A / 100));
        }
        double ExpoInOut(double A) {
            return (A / 100) == 0 ? 0 : (A / 100) == 1 ? 1 : (A / 100) < 0.5 ? std::pow(2, 20 * (A / 100) - 10) / 2 : (2 - std::pow(2, -20 * (A / 100) + 10)) / 2;
        }
        double BackIn(double A) {
            double c1 = 1.70158;
            double c3 = c1 + 1;
            return c3 * std::pow(A / 100, 3) - c1 * std::pow(A / 100, 2);
        }
        double BackOut(double A) {
            double c1 = 1.70158;
            double c3 = c1 + 1;
            return 1 + c3 * std::pow(A / 100 - 1, 3) + c1 * std::pow(A / 100 - 1, 2);
        }
        double BackInOut(double A) {
            double c1 = 1.70158;
            double c2 = c1 * 1.525;
            return (A / 100) < 0.5 ? (std::pow(2 * (A / 100), 2) * ((c2 + 1) * 2 * (A / 100) - c2)) / 2 : (std::pow(2 * (A / 100) - 2, 2) * ((c2 + 1) * ((A / 100) * 2 - 2) + c2) + 2) / 2;
        }
        double BounceOut(double A) {
            double n1 = 7.5625;
            double d1 = 2.75;
            if (A < 1 / d1) {
                return n1 * A * A;
            }
            else if (A < 2 / d1) {
                return n1 * (A -= 1.5 / d1) * A + 0.75;
            }
            else if (A < 2.5 / d1) {
                return n1 * (A -= 2.25 / d1) * A + 0.9375;
            }
            else {
                return n1 * (A -= 2.625 / d1) * A + 0.984375;
            }
        }
        double BounceIn(double A) {
            return 1 - BounceOut(1 - A);
        }
        double BounceInOut(double A) {
            return A < 0.5 ? (1 - BounceOut(1 - 2 * A)) / 2 : (1 + BounceOut(2 * A - 1)) / 2;
        }
    };
    // a timer, based on real time. 
    class Timer {

    private:
        std::chrono::high_resolution_clock::time_point startTime;

    public:
        Timer() {
            Reset();
        }

        void Reset() {
            startTime = std::chrono::high_resolution_clock::now();
        }

        double Get_Time() const {
            auto currentTime = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> elapsedTime = currentTime - startTime;
            return elapsedTime.count();
        }
    };

    SDL_Texture* Load_Sprite(SDL_Renderer* rend, std::string file);
    struct Sprite_Stack;
    struct animation {
        std::string file = "NULL";
        int rowCount = 1;
        int coloumnCount = 1;
        int frameCount = 1;
        int sheetW = 1;
        int sheetH = 1;
        double duration;
        animation(std::string f, int rC, int cC, int _sheetW, int _sheetH, double dur) {
            file = f;
            rowCount = rC;
            coloumnCount = cC;
            sheetW = _sheetW;
            sheetH = _sheetH;
            duration = dur;
            frameCount = rowCount * coloumnCount;
        }
        int currentFrame = 0;
        double elapsedTime = 0;
        
    };
    struct _layer {
        _layer(SDL_Texture* te, SDL_Rect* re) : t(te), r(re) {}
        SDL_Texture* t;
        SDL_Rect* r;
    };

    struct Sprite_Stack {
        Sprite_Stack(std::string f, int rC, int cC, int _height, int _sheetW, int _sheetH)  {
            spr = f;
            rowCount = rC;
            coloumnCount = cC;
            sheetW = _sheetW;
            sheetH = _sheetH;
            height = _height;
            frameCount = rowCount * coloumnCount;
            height = frameCount;
           
        }

        std::vector<_layer*> operator+ (Sprite_Stack b) {
            for (_layer* i : b.stack) stack.push_back(i);
            return stack;
        }

        std::string spr = "NULL";
        int rowCount = 1;
        int coloumnCount = 1;
        int frameCount = 1;
        int sheetW = 1;
        int sheetH = 1;
        int height = frameCount;

        std::vector<_layer*> stack = {};
        std::vector<animation*> anim = {};
        void Load_Stack(SDL_Renderer* rend) {
            int w = sheetW / rowCount;
            int h = sheetH / coloumnCount;
            for (int frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                int frameWidth = sheetW / coloumnCount;
                int frameHeight = sheetH / rowCount;
                
                int frameX = (frameIndex % coloumnCount) * frameWidth;
                int frameY = (frameIndex % rowCount) * frameHeight;

                SDL_Rect r = { frameX * 0, frameY * 0, frameWidth, frameHeight };
                stack.push_back(new _layer(Load_Sprite(rend, spr), &r));
            }   
            
        }
        void Set_Animation(std::vector<animation*> a) {
            anim = a;
        }
        void Delete_Animation() {
            anim = {};
        }

    };
    

    struct camera {
        int x = 0;
        int y = 0;
        int wW = 1;
        int wH = 1;
        double zoom = 100;
        camera() {}
        camera(int X, int Y, int WW, int WH) {
            x = X;
            y = Y;
            wW = WW;
            wH = WH;
        }
    };

    struct _texture {

        SDL_Rect dst;
        SDL_Texture* texture;
        Layer layer;
        int x, y, w, h;
        double angle;
        SDL_RendererFlip flip = SDL_FLIP_NONE;
        int displayOrder = 99999;
        _texture(int X, int Y, int W, int H, double Angle, SDL_Texture* _texture, SDL_Rect dest, Layer gamel) {
            texture = _texture;
            x = X;
            y = Y;
            w = W;
            h = H;
            angle = Angle;
            layer = gamel;
            dst = dest;
        }
    };

    struct key {
        bool pressed = false;
        bool released = false;
        bool held = false;
        bool allowed = true;
        SDL_KeyCode code = SDLK_a;
        int mouse_code = 0;
        bool isMouseKey = false;
        key(int c) { mouse_code = c; isMouseKey = true; }
        key(SDL_KeyCode c) { c = code; }
        bool Check(SDL_Event* e) {
            if (!isMouseKey) {
                if (!(e->key.keysym.sym == code)) return false;
                if (e->type == SDL_KEYDOWN) {
                    if (e->key.keysym.sym == code) {
                        pressed = true;
                        held = true;

                        allowed = false;
                        released = false;
                    }
                }
                if (e->type == SDL_KEYUP) {
                    if (e->key.keysym.sym == code) {
                        pressed = false;
                        held = false;

                        allowed = true;
                        released = true;
                    }
                }
                return e->key.keysym.sym == code;
            }
            else {
                if (!(e->key.keysym.sym == mouse_code)) return false;

                if (e->type == SDL_MOUSEBUTTONDOWN && e->key.keysym.sym == mouse_code) {
                    pressed = true;
                    held = true;

                    allowed = false;
                    released = false;
                }
                if (e->type == SDL_MOUSEBUTTONUP && e->key.keysym.sym == mouse_code) {
                    pressed = false;
                    held = false;

                    allowed = true;
                    released = true;
                }
                return e->key.keysym.sym == mouse_code;
            }
        }
        void Reset() {
            pressed = false;
            released = false;
        }
    };
    struct mouse {
        key left = { SDL_BUTTON_LEFT };
        key right = { SDL_BUTTON_RIGHT };
        int x = 0;
        int y = 0;
        b2Vec2 pos = { static_cast<float32> (0), static_cast<float32> (0) };
        double wheel_x = 0;
        double wheel_y = 0;

        bool lock = false;
        bool show = true;

        bool Check(SDL_Event* e) {
            if (e->type == SDL_MOUSEWHEEL) wheel_x = e->wheel.x, wheel_y = e->wheel.y;
            left.Check(e);
            right.Check(e);
            SDL_GetMouseState(&x, &y);
            pos = { static_cast<float32> (x), static_cast<float32> (y) };
            return (left.Check(e) || right.Check(e));
        }
        void Reset() {
            left.Reset();
            right.Reset();
        }
    };

    namespace No_Physics {
        class Window {
        public:
            
            bool operator== (Window o) {
                return win == o.win;
            }

            // the window itself,for sdl functions
            SDL_Window* win = nullptr;
            // window dimensions
            int W = 2, H = 2;
            // window display name
            std::string name = "window";
            // the window renderer, for sdl functions
            SDL_Renderer* rend = nullptr;
            // the window events

            // arguements: name,width,height,resizable (bool)
            Window(std::string _name, int _W, int _H, Uint32 flags = SHOWN) {

                if (SDL_Init(SDL_INIT_EVERYTHING) != 0) {
                    SDL_Log("Unable to initialize SDL: %s", SDL_GetError());
                    return;
                }
                win = SDL_CreateWindow(_name.c_str(), SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, _W, _H, flags);
                name = _name;
                if (!win) {
                    SDL_Log("Failed to create window: %s", SDL_GetError());
                    SDL_Quit();
                    return;
                }
                TTF_Init();

                rend = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED);

                if (!rend) {
                    SDL_Log("Failed to create renderer: %s", SDL_GetError());
                    SDL_DestroyWindow(win);
                    SDL_Quit();
                    return;
                }
                W = _W;
                H = _H;
                cam.wW = W;
                cam.wH = H;
            }
            virtual void Start() {}
            //----------------------------
            //           GENERAL         |
            //----------------------------

            // this is the most important function in this entire class.

            // add it to your while loop argument, and it will update the window,

            // and if you are using physics it will also update that.

            virtual bool Run() {
                // events
                Get_Events();
                // delta time
                dt = Get_DT();

                // fps cap
                Cap_FPS((max_FPS == 0 ? 2000 : max_FPS));

                // mouse lock
                if (m.lock) {
                    SDL_SetRelativeMouseMode(SDL_TRUE);
                    int x, y;

                    SDL_GetRelativeMouseState(&x, &y);
                    m.x += x;
                    m.y += y;
                }
                else {
                    SDL_SetRelativeMouseMode(SDL_FALSE);
                }

                // zoom
                double z = cam.zoom / 100;
                SDL_RenderSetScale(rend, z, z);

                // window size
                SDL_GetWindowSize(win, &W, &H);

                // fullscreen
                if (fullscreen) {
                    SDL_SetWindowFullscreen(win, SDL_WINDOW_FULLSCREEN);
                    if (k_escape.pressed) fullscreen = false;
                }
                else {
                    SDL_SetWindowFullscreen(win, 0);
                }

                // show cursor
                SDL_ShowCursor(m.show);

                // mouse pos
                if (!m.lock) SDL_GetMouseState(&m.x, &m.y);

                // get fps
                fps = FPS();

                // window title
                std::string new_name = (!display_FPS ? name : name + "    fps: " + std::to_string(fps));
                SDL_SetWindowTitle(win, new_name.c_str());

                // sort the sprites based on a display order
                
                // draw sprites
                for (_texture i : textures) {
                    SDL_Rect src = { i.x, i.y, i.w, i.h };
                    if (i.layer == BG_LAYER) SDL_RenderCopyEx(rend, i.texture, &i.dst, &src, i.angle, NULL, i.flip);
                }
                for (_texture i : textures) {

                    SDL_Rect src = { i.x, i.y, i.w, i.h };
                    if (i.layer = BG_LAYER) SDL_RenderCopyEx(rend, i.texture, &i.dst, &src, i.angle, NULL, i.flip);
                }
                for (_texture i : textures) {
                    SDL_Rect src = { i.x, i.y, i.w, i.h };
                    if (i.layer == UI_LAYER) SDL_RenderCopyEx(rend, i.texture, &i.dst, &src, i.angle, NULL, i.flip);
                }

                // update the window
                SDL_RenderPresent(rend);


                // clear the window
                if (clear) {
                    Clear();
                }
                
                Update();
                textures = {};
                if (!running) {
                    SDL_DestroyWindow(win);
                    SDL_DestroyRenderer(rend);
                }
                return running;
            }
            virtual void Update() {}
            // if the window is full screen ( fullscreen will automatically stop when you press the esc key.)
            bool fullscreen = false;

            // display fps on the window
            bool display_FPS = false;

            // fps as a variable
            int fps = 0;

            // delta time for animations and movement

            // delta time is the time since the last frame.
            double dt = 0;

            // set max frame rate
            int max_FPS = 0;


            // the window color
            SDL_Color color = { 255,255,255,255 };

            // clear the window with the window color.
            bool clear = true;

            // set window icon (this will not really work when you export your app,

            // the icon will just be the app icon
            void Set_Icon(std::string file) {
                SDL_Surface* s = SDL_LoadBMP(file.c_str());
                SDL_SetWindowIcon(win, s);
            }

            bool inView(b2Vec2 i, int viewBufferPixels = 0) {
                return (i.x > W + viewBufferPixels || i.x < 0 - viewBufferPixels || i.y > H + viewBufferPixels || i.y < 0 - viewBufferPixels);

            }

            //--------------------------
            //         DRAW            |
            //--------------------------
            
            SDL_Texture* Load_Sprite(std::string file) {
                SDL_Texture* spriteTexture = SDL_CreateTextureFromSurface(rend, SDL_LoadBMP(file.c_str()));
                if (!spriteTexture) {
                    SDL_Log("Unable to load sprite texture: %s", SDL_GetError());
                }
                return spriteTexture;
            }
            
            void Draw_String(int x, int y, int size, double angle, std::string text, std::string f, SDL_Color color) {
                TTF_Font* font = TTF_OpenFont(f.c_str(), size);
                if (!rend || !font) {
                    std::cerr << "Renderer or font is invalid." << std::endl;
                    return;
                }

                // Create a transformation matrix for rotating the text
                SDL_Point center = { x, y };
                SDL_Rect textRect = { 0, 0, 0, 0 };
                SDL_Surface* textSurface = nullptr;
                SDL_Texture* textTexture = nullptr;

                // Rotate the text
                if (angle != 0.0) {
                    SDL_Surface* tempSurface = TTF_RenderText_Solid(font, text.c_str(), color);
                    if (!tempSurface) {
                        std::cerr << "Text rendering failed: " << TTF_GetError() << std::endl;
                        return;
                    }

                    SDL_Texture* tempTexture = SDL_CreateTextureFromSurface(rend, tempSurface);
                    SDL_FreeSurface(tempSurface);
                    if (!tempTexture) {
                        std::cerr << "Texture creation failed: " << SDL_GetError() << std::endl;
                        return;
                    }

                    SDL_QueryTexture(tempTexture, nullptr, nullptr, &textRect.w, &textRect.h);

                    SDL_SetRenderTarget(rend, nullptr);

                    SDL_RenderCopyEx(rend, tempTexture, nullptr, &textRect, angle, &center, SDL_FLIP_NONE);

                    SDL_DestroyTexture(tempTexture);
                }
                else {
                    textSurface = TTF_RenderText_Solid(font, text.c_str(), color);
                    if (!textSurface) {
                        std::cerr << "Text rendering failed: " << TTF_GetError() << std::endl;
                        return;
                    }

                    textTexture = SDL_CreateTextureFromSurface(rend, textSurface);
                    if (!textTexture) {
                        std::cerr << "Texture creation failed: " << SDL_GetError() << std::endl;
                        return;
                    }

                    SDL_QueryTexture(textTexture, nullptr, nullptr, &textRect.w, &textRect.h);
                }

                textRect.x = x;
                textRect.y = y;
                textRect.w = int(size * textRect.w / textRect.h);
                textRect.h = size;

                SDL_RenderCopyEx(rend, textTexture, nullptr, &textRect, angle, &center, SDL_FLIP_NONE);
                SDL_DestroyTexture(textTexture);
                SDL_FreeSurface(textSurface);


            }
            SDL_Rect Get_String_Rect(int x, int y, int size, double angle, std::string text, std::string f, SDL_Color color) {
                TTF_Font* font = TTF_OpenFont(f.c_str(), size);
                if (!rend || !font) {
                    std::cerr << "Renderer or font is invalid." << std::endl;
                    return { 0,0,0,0 };
                }

                // Create a transformation matrix for rotating the text
                SDL_Point center = { x, y };
                SDL_Rect textRect = { 0, 0, 0, 0 };
                SDL_Surface* textSurface = nullptr;
                SDL_Texture* textTexture = nullptr;

                // Rotate the text
                if (angle != 0.0) {
                    SDL_Surface* tempSurface = TTF_RenderText_Solid(font, text.c_str(), color);
                    if (!tempSurface) {
                        std::cerr << "Text rendering failed: " << TTF_GetError() << std::endl;
                        return{ 0,0,0,0 };
                    }

                    SDL_Texture* tempTexture = SDL_CreateTextureFromSurface(rend, tempSurface);
                    SDL_FreeSurface(tempSurface);
                    if (!tempTexture) {
                        std::cerr << "Texture creation failed: " << SDL_GetError() << std::endl;
                        return{ 0,0,0,0 };
                    }

                    SDL_QueryTexture(tempTexture, nullptr, nullptr, &textRect.w, &textRect.h);

                    SDL_SetRenderTarget(rend, nullptr);

                    SDL_RenderCopyEx(rend, tempTexture, nullptr, &textRect, angle, &center, SDL_FLIP_NONE);

                    SDL_DestroyTexture(tempTexture);
                }
                else {
                    textSurface = TTF_RenderText_Solid(font, text.c_str(), color);
                    if (!textSurface) {
                        std::cerr << "Text rendering failed: " << TTF_GetError() << std::endl;
                        return{ 0,0,0,0 };
                    }

                    textTexture = SDL_CreateTextureFromSurface(rend, textSurface);
                    if (!textTexture) {
                        std::cerr << "Texture creation failed: " << SDL_GetError() << std::endl;
                        return{ 0,0,0,0 };
                    }

                    SDL_QueryTexture(textTexture, nullptr, nullptr, &textRect.w, &textRect.h);
                }

                textRect.x = x;
                textRect.y = y;
                textRect.w = int(size * textRect.w / textRect.h);
                textRect.h = size;

                SDL_DestroyTexture(textTexture);
                SDL_FreeSurface(textSurface);
                return textRect;

            }

            // draw a pixel on the screen
            void Draw(int x, int y, SDL_Color color) {
                SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                SDL_RenderDrawPoint(rend, x, y);
            }
            void Draw(b2Vec2 point, SDL_Color color) {
                SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                SDL_RenderDrawPoint(rend, point.x, point.y);
                // Optionally use 'layer' argument for layer-specific logic
            }

            void Draw_Texture(int x, int y, int width, int height, double angle, SDL_Texture* t, SDL_Rect sorcrect = { 10,10,9,9 }, Layer layer = GAME_LAYER, int DisplayOrder = 99999, SDL_RendererFlip flip = SDL_FLIP_NONE) {
                SDL_Rect src = { static_cast<int> (x), static_cast<int> (y), static_cast<int> (width), static_cast<int> (height) };
                if (sorcrect.x == 10 && sorcrect.y == 10 && sorcrect.w == 9 && sorcrect.h == 9) sorcrect = { 0,0,W,H };
                _texture te = { x,y,width,height,angle,t, sorcrect, layer };
                te.displayOrder = DisplayOrder;
                te.flip = flip;
              
                textures.push_back(te);
            }
            void Draw_Sprite(int x, int y, int width, int height, double angle, std::string file, SDL_Rect sorcrect = { 10,10,9,9 }, Layer layer = GAME_LAYER, int DisplayOrder = 99999, SDL_RendererFlip flip = SDL_FLIP_NONE) {
                SDL_Texture* spriteTexture = SDL_CreateTextureFromSurface(rend, SDL_LoadBMP(file.c_str()));
                SDL_Rect src = { x,y,width,height };
                if (sorcrect.x == 10 && sorcrect.y == 10 && sorcrect.w == 9 && sorcrect.h == 9) sorcrect = { 0,0,W,H };

                _texture te = { x,y,width,height,angle, spriteTexture, sorcrect, layer };
                te.displayOrder = DisplayOrder;
                te.flip = flip;
                textures.push_back(te);
            }

            // draw a rectangle outline
            void Draw_Rect(int X, int Y, int W, int H, SDL_Color color) {
                int R = color.r;
                int G = color.g;
                int B = color.b;
                int A = color.a;
                SDL_Rect squareRect = { X, Y, W, H };

                SDL_SetRenderDrawColor(rend, R, G, B, A);
                SDL_RenderDrawRect(rend, &squareRect);
                // Optionally use 'layer' argument for layer-specific logic
            }
            void Draw_Rect(b2Vec2 pos, int w, int h, SDL_Color color) {
                int R = color.r;
                int G = color.g;
                int B = color.b;
                int A = color.a;
                SDL_Rect squareRect = { pos.x, pos.y, w, h };

                SDL_SetRenderDrawColor(rend, R, G, B, A);
                SDL_RenderDrawRect(rend, &squareRect);
                // Optionally use 'layer' argument for layer-specific logic
            }

            // draw a line
            void Draw_Line(int X, int Y, int X1, int Y1, SDL_Color color) {
                int R = color.r;
                int G = color.g;
                int B = color.b;
                int A = color.a;
                SDL_SetRenderDrawColor(rend, R, G, B, A);
                SDL_RenderDrawLine(rend, X, Y, X1, Y1);
            }
            void Draw_Line(b2Vec2 pos, b2Vec2 pos2, SDL_Color color) {
                int R = color.r;
                int G = color.g;
                int B = color.b;
                int A = color.a;
                SDL_SetRenderDrawColor(rend, R, G, B, A);
                SDL_RenderDrawLine(rend, pos.x, pos.y, pos2.x, pos2.y);
            }

            // draw a filled rectangle
            void Fill_Rect(int X, int Y, int W, int H, SDL_Color color) {
                int R = color.r;
                int G = color.g;
                int B = color.b;
                int A = color.a;
                SDL_Rect squareRect = { X, Y, W, H };

                SDL_SetRenderDrawBlendMode(rend, SDL_BLENDMODE_BLEND);
                SDL_SetRenderDrawColor(rend, R, G, B, A);
                SDL_RenderFillRect(rend, &squareRect);
                // Optionally use 'layer' argument for layer-specific logic
            }
            void Fill_Rect(b2Vec2 pos, int W, int H, SDL_Color color) {
                int R = color.r;
                int G = color.g;
                int B = color.b;
                int A = color.a;
                SDL_Rect squareRect = { pos.x, pos.y, W, H };

                SDL_SetRenderDrawBlendMode(rend, SDL_BLENDMODE_BLEND);
                SDL_SetRenderDrawColor(rend, R, G, B, A);
                SDL_RenderFillRect(rend, &squareRect);
                // Optionally use 'layer' argument for layer-specific logic
            }

            // draw and fill a circle
            void Draw_Circle(int x, int y, int rad, SDL_Color color) {
                b2Vec2 last = AngleAndDistance_To(x, y, 0, rad / 2);
                b2Vec2 first = last;
                for (int angle = 1; angle <= 360; angle++) {
                    b2Vec2 point = AngleAndDistance_To(x, y, angle, rad / 2);
                    SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                    SDL_RenderDrawLine(rend, last.x, last.y, point.x, point.y);
                    last = point;
                }
            }
            void Fill_Circle(int x, int y, int rad, SDL_Color color) {

                b2Vec2 last = AngleAndDistance_To(x, y, 0, rad / 2);
                b2Vec2 first = last;
                for (int angle = 1; angle <= 360; angle++) {
                    b2Vec2 point = AngleAndDistance_To(x, y, angle, rad / 2);

                    std::vector<SDL_Vertex> vertexArray {
                        {{last.x, last.y }, color, { point.x, point.y }},
                        { {point.x, point.y },	color, { static_cast<float> (x), static_cast<float> (y) } },
                        { {static_cast<float> (x), static_cast<float> (y)},	color, {last.x, last.y} },
                    };

                    // Now you can use vertexArray in your SDL_RenderGeometry function call
                    SDL_RenderGeometry(rend, NULL, vertexArray.data(), 3, NULL, 0);

                    last = point;
                }
            }

            // draw and fill a non convex polygon shape
            void Draw_Polygon(int x, int y, std::vector<b2Vec2> v, SDL_Color c) {
                if (v.size() < 2) return;

                b2Vec2 first = v[0];
                b2Vec2 previous = first;

                for (size_t i = 1; i < v.size(); i++) {
                    b2Vec2 current = v[i];
                    Draw_Line(previous.x + x, previous.y + y, current.x + x, current.y + y, c);
                    previous = current;
                }

                // Connect the last point to the first one to close the shape
                Draw_Line(previous.x + x, previous.y + y, first.x + x, first.y + y, c);

            }
            void Fill_Polygon(int x, int y, std::vector<b2Vec2> vertices, const SDL_Color color) {
                int n = vertices.size();

                SDL_Vertex* verts = new SDL_Vertex[n];
                for (int i = 0; i < n; i++) {
                    verts[i].position.x = vertices[i].x + x;
                    verts[i].position.y = vertices[i].y + y;
                    verts[i].color = color;
                }

                int* indices = new int[(n - 2) * 3];
                for (int i = 1; i < n - 1; i++) {
                    indices[3 * (i - 1)] = 0;
                    indices[3 * i - 2] = i;
                    indices[3 * i - 1] = i + 1;
                }

                SDL_RenderGeometry(rend, NULL, verts, n, indices, (n - 2) * 3);
                delete indices;
                delete verts;
            }


            // draw a sprite sheet animation
            void Draw_Animation(int x, int y, int w, int h, double angle, animation* an, int displayOrder = 99999, Layer layer = GAME_LAYER, SDL_RendererFlip flip = SDL_FLIP_NONE) {
           
                double frameDuration = an->duration / an->frameCount;
                an->elapsedTime += dt;
                int NextFrame = an->currentFrame + 1;
                
                Draw_Frame(an->currentFrame, x, y, w, h, angle, an, layer, displayOrder, flip);

                if (an->elapsedTime >= frameDuration * NextFrame) an->currentFrame++;
                if (an->elapsedTime >= an->duration) {
                    an->currentFrame = 0;
                    an->elapsedTime = 0;
                }

            }
            void Draw_Frame(int frameIndex, int x, int y, int w, int h, double angle, animation* an, Layer layer = GAME_LAYER, int displayOrder = 99999, SDL_RendererFlip flip = SDL_FLIP_NONE) {
                if (frameIndex >= an->frameCount) return;

                int frameWidth = an->sheetW / an->coloumnCount;
                int frameHeight = an->sheetH / an->rowCount;

                // Calculate the position of the frame on the sprite sheet based on frameIndex
                int frameX = (frameIndex % an->coloumnCount) * frameWidth;
                int frameY = (frameIndex / an->coloumnCount) * frameHeight;

                // Calculate the scaled frame width and height based on w and h arguments
                int scaledFrameWidth = w;
                int scaledFrameHeight = h;

                SDL_Rect r = { frameX, frameY, frameWidth, frameHeight };

                // Call Draw_Sprite to draw the frame from the sprite sheet with the specified w and h
                Draw_Sprite(x, y, scaledFrameWidth, scaledFrameHeight, angle, an->file, r, layer, displayOrder, flip);
            }
            
            void Draw_Sprite_Stack(int x, int y, int w, int h, double angle, Sprite_Stack* s, Layer layer = GAME_LAYER, int displayOrder = 99999, SDL_Rect r = { 10, 10, 9 ,9 }, SDL_RendererFlip flip = SDL_FLIP_NONE) {
                
                if (s->anim.empty()) {
                    int a = 0;
                    for (_layer* i : s->stack) {
                        Draw_Texture(x, y - s->height / s->frameCount * a, w, h, angle, i->t, { 0,0,W,H }, layer, displayOrder, flip);
                        a++;
                    }
                }
                else {
                    for (animation* a : s->anim) Draw_Animation(x, y - s->height / s->frameCount, w, h, angle, a, displayOrder, layer, flip);
                }
                // TODO: fix anim y pos
            }

            //---------------------------
            //           OTHER          |
            //---------------------------

            // get events that are not already detected by the class
            bool Event_Loop() {
                static int iteration = 0;
                if (iteration == events.size()) {
                    iteration = 0;
                    return false;
                }
                event = events[iteration];
                iteration++;

                event.window.windowID = SDL_GetWindowID(win);
                return true;
            }

            // event that you got from the Event_Loop() function
            SDL_Event event;

            // game camera, this only affects sprites and shapes tagged with GAME_OBJECT
            camera cam = { 0,0,W,H };

            void Close() { running = false; }

            std::vector<_texture> textures;
            //--------------------
            //       KEYS        |
            //--------------------

            key k_a = { SDLK_a };
            key k_b = { SDLK_b };
            key k_c = { SDLK_c };
            key k_d = { SDLK_d };
            key k_e = { SDLK_e };
            key k_f = { SDLK_f };
            key k_g = { SDLK_g };
            key k_h = { SDLK_h };
            key k_i = { SDLK_i };
            key k_j = { SDLK_j };
            key k_k = { SDLK_k };
            key k_l = { SDLK_l };
            key k_m = { SDLK_m };
            key k_n = { SDLK_n };
            key k_o = { SDLK_o };
            key k_p = { SDLK_p };
            key k_q = { SDLK_q };
            key k_r = { SDLK_r };
            key k_s = { SDLK_s };
            key k_t = { SDLK_t };
            key k_u = { SDLK_u };
            key k_v = { SDLK_v };
            key k_w = { SDLK_w };
            key k_x = { SDLK_x };
            key k_y = { SDLK_y };
            key k_z = { SDLK_z };

            // Additional commonly used keys
            key k_space = { SDLK_SPACE };
            key k_enter = { SDLK_RETURN };
            key k_escape = { SDLK_ESCAPE };
            key k_shift = { SDLK_LSHIFT };
            key k_ctrl = { SDLK_LCTRL };
            key k_alt = { SDLK_LALT };

            // Special characters
            key k_semicolon = { SDLK_SEMICOLON };
            key k_apostrophe = { SDLK_QUOTE };
            key k_period = { SDLK_PERIOD };
            key k_comma = { SDLK_COMMA };
            key k_slash = { SDLK_SLASH };
            key k_backslash = { SDLK_BACKSLASH };
            key k_asterisk = { SDLK_ASTERISK };
            key k_equals = { SDLK_EQUALS };
            key k_minus = { SDLK_MINUS };

            // Number keys (0-9)
            key k_0 = { SDLK_0 };
            key k_1 = { SDLK_1 };
            key k_2 = { SDLK_2 };
            key k_3 = { SDLK_3 };
            key k_4 = { SDLK_4 };
            key k_5 = { SDLK_5 };
            key k_6 = { SDLK_6 };
            key k_7 = { SDLK_7 };
            key k_8 = { SDLK_8 };
            key k_9 = { SDLK_9 };

            // Arrow keys
            key k_up = { SDLK_UP };
            key k_down = { SDLK_DOWN };
            key k_left = { SDLK_LEFT };
            key k_right = { SDLK_RIGHT };

            mouse m;

        protected:


            SDL_Event ev;
            std::vector<SDL_Event> events;

            // if the window is running
            bool running = true;

            int last_m_x = 0;
            int last_m_y = 0;
            double lastfps = 0;

            void Reset_Events() {
                events = {};
                // keyboard events
                k_a.Reset();
                k_b.Reset();
                k_c.Reset();
                k_d.Reset();
                k_e.Reset();
                k_f.Reset();
                k_g.Reset();
                k_h.Reset();
                k_i.Reset();
                k_j.Reset();
                k_k.Reset();
                k_l.Reset();
                k_m.Reset();
                k_n.Reset();
                k_o.Reset();
                k_p.Reset();
                k_q.Reset();
                k_r.Reset();
                k_s.Reset();
                k_t.Reset();
                k_u.Reset();
                k_v.Reset();
                k_w.Reset();
                k_x.Reset();
                k_y.Reset();
                k_z.Reset();
                k_space.Reset();
                k_enter.Reset();
                k_escape.Reset();
                k_shift.Reset();
                k_ctrl.Reset();
                k_alt.Reset();
                k_semicolon.Reset();
                k_apostrophe.Reset();
                k_period.Reset();
                k_comma.Reset();
                k_slash.Reset();
                k_backslash.Reset();
                k_asterisk.Reset();
                k_equals.Reset();
                k_minus.Reset();
                k_0.Reset();
                k_1.Reset();
                k_2.Reset();
                k_3.Reset();
                k_4.Reset();
                k_5.Reset();
                k_6.Reset();
                k_7.Reset();
                k_8.Reset();
                k_9.Reset();
                k_up.Reset();
                k_down.Reset();
                k_left.Reset();
                k_right.Reset();
                m.Reset();
            }

            void Get_Events() {
                Reset_Events();
                while (SDL_PollEvent(&ev)) {
                    if (ev.type == SDL_QUIT) running = false;

                    else if (k_a.Check(&ev));
                    else if (k_b.Check(&ev));
                    else if (k_c.Check(&ev));
                    else if (k_d.Check(&ev));
                    else if (k_e.Check(&ev));
                    else if (k_f.Check(&ev));
                    else if (k_g.Check(&ev));
                    else if (k_h.Check(&ev));
                    else if (k_i.Check(&ev));
                    else if (k_j.Check(&ev));
                    else if (k_k.Check(&ev));
                    else if (k_l.Check(&ev));
                    else if (k_m.Check(&ev));
                    else if (k_n.Check(&ev));
                    else if (k_o.Check(&ev));
                    else if (k_p.Check(&ev));
                    else if (k_q.Check(&ev));
                    else if (k_r.Check(&ev));
                    else if (k_s.Check(&ev));
                    else if (k_t.Check(&ev));
                    else if (k_u.Check(&ev));
                    else if (k_v.Check(&ev));
                    else if (k_w.Check(&ev));
                    else if (k_x.Check(&ev));
                    else if (k_y.Check(&ev));
                    else if (k_z.Check(&ev));
                    else if (k_space.Check(&ev));
                    else if (k_enter.Check(&ev));
                    else if (k_escape.Check(&ev));
                    else if (k_shift.Check(&ev));
                    else if (k_ctrl.Check(&ev));
                    else if (k_alt.Check(&ev));
                    else if (k_semicolon.Check(&ev));
                    else if (k_apostrophe.Check(&ev));
                    else if (k_period.Check(&ev));
                    else if (k_comma.Check(&ev));
                    else if (k_slash.Check(&ev));
                    else if (k_backslash.Check(&ev));
                    else if (k_asterisk.Check(&ev));
                    else if (k_equals.Check(&ev));
                    else if (k_minus.Check(&ev));
                    else if (k_0.Check(&ev));
                    else if (k_1.Check(&ev));
                    else if (k_2.Check(&ev));
                    else if (k_3.Check(&ev));
                    else if (k_4.Check(&ev));
                    else if (k_5.Check(&ev));
                    else if (k_6.Check(&ev));
                    else if (k_7.Check(&ev));
                    else if (k_8.Check(&ev));
                    else if (k_9.Check(&ev));
                    else if (k_up.Check(&ev));
                    else if (k_down.Check(&ev));
                    else if (k_left.Check(&ev));
                    else if (k_right.Check(&ev));
                    else if (m.Check(&ev));
                    else events.push_back(ev);
                }
            }

            void Clear() {
                SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                SDL_RenderClear(rend);
            }

            SDL_Rect Merge_Rectangles(SDL_Rect* rect1, SDL_Rect* rect2) {
                SDL_Rect mergedRect;
                mergedRect.x = min(rect1->x, rect2->x);
                mergedRect.y = min(rect1->y, rect2->y);
                mergedRect.w = max(rect1->x + rect1->w, rect2->x + rect2->w) - mergedRect.x;
                mergedRect.h = max(rect1->y + rect1->h, rect2->y + rect2->h) - mergedRect.y;
                return mergedRect;
            }

            void Cap_FPS(int cap) {
                // Calculate the maximum frame time allowed for the desired FPS
                double maxFT = 1.0 / cap;

                // Get the time at the end of the frame
                double frameEndTime = SDL_GetTicks() / 1000.0;

                // Calculate the time it took to process the current frame
                double frameTime = frameEndTime - lastFrameEndTime;

                // Calculate the delay needed to cap the frame rate (if necessary)
                double delayTime = maxFT - frameTime;

                // Check if delay is needed and perform it
                if (delayTime > 0) {
                    SDL_Delay(static_cast<Uint32>(delayTime * 1000.0)); // Convert to milliseconds
                }

                // Update the time for the end of the next frame
                lastFrameEndTime = SDL_GetTicks() / 1000.0;
            }

            double lastFrameEndTime = 0.0;

            double FPS() {
                static int frameCount = 0;
                static double lastTime = 0.0;
                double currentTime = SDL_GetTicks() / 1000.0;  // Get current time in seconds
                frameCount++;

                if (currentTime - lastTime >= 1.0) {
                    double fps = static_cast<double>(frameCount) / (currentTime - lastTime);
                    lastTime = currentTime;
                    frameCount = 0;
                    lastfps = fps; // Update lastFPS when the calculation is done
                }

                return lastfps; // Return lastFPS, which may be the last calculated FPS or -1.0
            }

            double Get_DT() {
                static double lastTime = SDL_GetTicks() / 1000.0;
                double currentTime = SDL_GetTicks() / 1000.0;
                double deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                return deltaTime;
            }

        };
    }
    namespace Physics {

        struct circle {
            circle(double ra) : rad(ra) {}
            double rad;
        };
        struct rect {
            rect(double iw, double ih) : w(iw), h(ih) {}
            double w = 0;
            double h = 0;
        };
        struct polygon {
            polygon(std::vector<b2Vec2> p) : points(p) {}
            std::vector<b2Vec2> points;
        };

        struct dimension {
            double w = 0;
            double h = 0;
            double rad = 0;
            std::vector<b2Vec2> points;
            rect As_Square() {
                return { w,h };
            }
            circle As_Circle() {
                return { rad };
            }
            polygon As_Polygon() {
                return { points };
            }
        };
        struct type {
        public:
            type() {}
            type(std::string _spr = "NULL", rect d = rect(32, 32), b2BodyType _b_type = b2_dynamicBody) {
                
                spr = _spr;
                b_type = _b_type;
                dimension.w = d.w;
                dimension.h = d.h;
                c_type = 2;
                mass = 40;
            }
            type(std::string _spr = "NULL", circle d = circle(40), b2BodyType _b_type = b2_dynamicBody) {
                
                spr = _spr;
                b_type = _b_type;
                dimension.rad = d.rad;
                c_type = 1;
                mass = 40;
            }
            type(std::string _spr = "NULL", polygon d = { {} }, b2BodyType _b_type = b2_dynamicBody) {
                
                spr = _spr;
                b_type = _b_type;
                dimension.points = d.points;
                c_type = 3;
                mass = 40;
            }
            std::string spr = "NULL";
            b2BodyType b_type = b2_dynamicBody;
            int c_type = 2;
            dimension dimension;
            double mass = 40;
            std::vector <b2Vec2> points;
        };

        struct _rc {

            _rc() {}
            _rc(b2World* worl, double _x1, double _y1, bool st, double _x, double _y, b2Body* _b1, b2Body* _b2) {
                x1 = _x1;
                world = worl;
                y1 = _y1;
                b1 = _b1;
                b2 = _b2;
                stop = st;
                x = _x;
                y = _y;
            }
            std::vector<b2Body*> bodies;
            double x1 = 0;
            double x = 0;
            double y1 = 0;
            double y = 0;
            b2Body* b1 = nullptr;
            b2Body* b2 = nullptr;
            double normal = 0;
            bool stop = false;
            float fraction = 0.0;
            b2World* world = nullptr;
            b2RayCastInput inp;
            b2RayCastOutput out;
            b2Vec2 hitPoint;
            bool check() {
                bodies = {};

                b2Vec2 st = b1->GetPosition();
                b2Vec2 en = { static_cast<float32> (x1), static_cast<float32> (y1) };
                b2RayCastInput input;
                inp = input;
                input.p1 = st;
                input.p2 = en;
                input.maxFraction = 1;
                b2RayCastOutput output;
                b2Vec2 inters;
                bool hit = false;
                float closestFraction = 1; //start with end of line as p2
                b2Vec2 intersectionNormal(0, 0);
                for (b2Body* b = world->GetBodyList(); b; b = b->GetNext()) {
                    b2Fixture* fixt = b->GetFixtureList();
                    if (b == b1) continue;
                    bool is = (fixt == b2->GetFixtureList());

                    if (!fixt->RayCast(&output, input, 0)) continue;
                    if (output.fraction < closestFraction) {
                        hit = is;

                        closestFraction = output.fraction;
                        intersectionNormal = output.normal;

                        if (hit) {
                            bodies.push_back(fixt->GetBody());
                        }

                        // Calculate the angle in radians
                        normal = std::atan2(output.normal.y, output.normal.x);

                        // Convert the angle to degrees if needed
                        normal *= 180.0f / b2_pi;
                    }

                }
                fraction = closestFraction;
                b2Vec2 intersectionPoint = st + closestFraction * (en - st);
                hitPoint = intersectionPoint;
                if (!hit && !stop) hitPoint = input.p2;
                return hit;
            }
        };
        struct raycast {
            std::vector<type*> typesHit;
            bool hit = false;
            float normal = 0;
            float dist = 0;
            double x = 0;
            double y = 0;
            double length = 0;
            double angle = 0;
        };

        struct emit {
            emit() {}
            emit(double _force, double _angle, b2Body* _from) : force(_force), angle(_angle), from(_from) {
            
            }
            double force = 0;
            double angle = 0;
            b2Body* from = nullptr;
        };

        struct attach {
            bool isAttached = false;
            b2Body* from;
            double offsetX = 0;
            double offsetY = 0;
            bool match_angle = false;
        };

        class Obj;
        struct collision {
            std::unordered_map<Obj*, bool> Obj;
            std::unordered_map<type*, bool> Type;
        };

        class Obj {
        public:

            // Constructors and Initialization
            Obj() {
            }
            Obj(type* t, b2World* _world, double _x, double _y, emit* emit = nullptr) {
                world = _world;

                double w = t->dimension.w - 1;
                double h = t->dimension.h - 1;

                b_type = t->b_type;
                c_type = t->c_type;
                Type = t;

                mass = t->mass;

                sprite = t->spr;
                em = emit;

                switch (c_type) {
                case CIRCLE_SHAPE:// ignore the density calculations being wrong for circles and polygons and circles.
                    Define_Circle(_x / 32, _y / 32, w / 2, w / 32 * h / 32 / mass, b_type);
                    break;
                    
                case RECT_SHAPE:
                    Define_Rect(_x / 32, _y / 32, w / 32 * h / 32 / mass, b_type);
                    break;

                case POLYGON_SHAPE:
                    Define_Polygon(_x / 32, _y / 32, t->points, w / 32 * h / 32 / mass, b_type);
                }
                Set_Pos(_x, _y);
                if (att.isAttached) {
                    Set_Solid(false);
                    Set_Pos(att.from->GetWorldCenter().x * 32 + att.offsetX, att.from->GetWorldCenter().y * -32 + att.offsetX);
                    if (att.match_angle) Set_Angle(body->GetAngle() * (180 / M_PI));
                }
                if (em != nullptr) {
                    Angular_Impulse(em->force * 100, em->angle);
                    b2Vec2 p = { em->from->GetWorldCenter().x * 32, em->from->GetWorldCenter().y * -32 };

                    if (!emHasCollided) {
                        raycast r = RayCast(
                            p,
                            em->from,
                            false,
                            false
                        );
                        emHasCollided = (r.hit && r.dist >= 5);
                    }
                    Set_Solid(emHasCollided);
                    body->SetUserData(this);

                }

                Define();
            }

            // constructor as a function
            void define(type* t, b2World* _world, double _x, double _y) {
                world = _world;
                double w = t->dimension.w - 1,
                    h = t->dimension.h - 1;
                b_type = t->b_type,
                    mass = t->mass,
                    c_type = t->c_type,
                    Type = t,
                    sprite = t->spr;

                switch (c_type) {
                case CIRCLE_SHAPE:
                    Define_Circle(_x, _y, w / 2, (M_PI * w * w) / mass, b_type);
                    break;
                case RECT_SHAPE:
                    Define_Rect(_x, _y, w * h / mass, b_type);
                    break;
                case POLYGON_SHAPE:
                    Define_Polygon(_x, _y, t->points, w * h / mass, b_type);
                }
                Set_Pos(_x, _y);

                if (att.isAttached) {
                    body->SetActive(false);
                    Set_Pos(att.from->GetWorldCenter().x * 32 + att.offsetX, att.from->GetWorldCenter().y * -32 + att.offsetX);
                    if (att.match_angle) Set_Angle(body->GetAngle() * (180 / M_PI));
                }
                if (em != nullptr) {
                    Angular_Impulse(em->force * 100, em->angle);
                    b2Vec2 p = { em->from->GetWorldCenter().x * 32, em->from->GetWorldCenter().y * -32 };

                    if (!emHasCollided) {

                        raycast r = RayCast(
                            p,
                            em->from,
                            false,
                            false
                        );
                        emHasCollided = (r.hit && r.dist >= 5);
                    }
                    Set_Solid(emHasCollided);
                }
                body->SetUserData(this);
                Define();

            }
            virtual void Define() { body->SetUserData(this); }
            // Member Variables
            type* Type = nullptr;
            int c_type = 0;
            bool SleepWhenOutOfView = false;
            int ViewBufferPixels = 100;

            float mass = 10;
            int DisplayOrder = 99999;
            SDL_RendererFlip flip = SDL_FLIP_NONE;


            // Box2D Physics Members
            b2Body* body = nullptr;
            SDL_Renderer* rend = nullptr;

            // animations and drawing
            std::string sprite = "NULL";
            animation* anim = nullptr;
            Sprite_Stack* stack = nullptr;

            // Getter for Angle
            double Get_Angle() {
                return body->GetAngle() * -1;
            }

            // Setter for Angle
            double Set_Angle(double angl) {
                body->SetTransform(body->GetPosition(), angl * (M_PI / 180) * (-1));
                return angl;
            }

            void Set_Dimensions(double nw, double nh) {
                if (Type->c_type == POLYGON_SHAPE || Type->c_type == RECT_SHAPE) {
                    double wm = nw / Get_Dimensions().w;
                    double hm = nh / Get_Dimensions().h;
                    std::vector<b2Vec2> po;
                    b2PolygonShape* sh = static_cast<b2PolygonShape*> (body->GetFixtureList()->GetShape());
                    for (int i = 0; i < sh->GetVertexCount(); i++) {
                        b2Vec2 v = sh->GetVertex(i);
                        po.push_back(b2Vec2(v.x * wm, v.y * hm));
                    }
                    sh->Set(po.data(), po.size());
                }
                else static_cast<b2CircleShape*> (body->GetFixtureList()->GetShape())->m_radius = nw / 32;
                
            }

            dimension Get_Dimensions() {
                dimension out;
                
                if (Type->c_type != CIRCLE_SHAPE) {
                    double sx = 9999999999;
                    double sy = 9999999999;
                    double bx = -9999999999;
                    double by = -9999999999;

                    b2PolygonShape* sh = static_cast<b2PolygonShape*>(body->GetFixtureList()->GetShape());

                    // Initialize min and max values with the first vertex
                    b2Vec2 firstVertex = sh->GetVertex(0);
                    sx = firstVertex.x * 32;
                    sy = firstVertex.y * 32;
                    bx = sx;
                    by = sy;

                    for (int i = 1; i < sh->GetVertexCount(); i++) {
                        b2Vec2 v = sh->GetVertex(i);
                        sx = min(sx, v.x * 32);
                        sy = min(sy, v.y * 32);
                        bx = max(bx, v.x * 32);
                        by = max(by, v.y * 32);
                    }
                    
                    out.w = abs((bx) - (sx));
                    out.h = abs((by)-(sy));
                    return out;
                }

                else out.rad = static_cast<b2CircleShape*> (body->GetFixtureList()->GetShape())->m_radius * -32;

                return out;
                }

            // Set gravity 
            void Set_Gravity(bool i) {
                body->SetGravityScale(i);
            }
            bool Get_Gravity() {
                return static_cast<bool> (body->GetGravityScale());
            }


            // Set Renderer and Camera
            void Set_Renderer(SDL_Renderer* renderer, camera* camera) {
                rend = renderer;
                cam = camera;
            }

            // jump
            void Impulse(double x, double y) {
                body->ApplyLinearImpulseToCenter({ static_cast<float32>(x / 5), static_cast<float32>(-y / 5) }, true);
            }

            // jump at angle
            void Angular_Impulse(double force, double angle) {
                float radians = angle * (M_PI / 180.0f);

                // Calculate the X and Y components of the force vector
                float forceX = force * cos(radians);
                float forceY = force * sin(radians);

                // Apply the force to the body
                b2Vec2 forceVector(forceX, forceY);
                body->ApplyLinearImpulseToCenter({ static_cast<float32>(forceX / 5), static_cast<float32>(-forceY / 5) }, true);
            }

            // set linear velocity
            void Set_Velocity(double x, double y) {
               
                b2Vec2 desiredVel = { static_cast<float32>(x / 5), static_cast<float32>(-y / 5) };

                b2Vec2 currentVel = body->GetLinearVelocity();
                b2Vec2 velChange(desiredVel.x - currentVel.x, desiredVel.y - currentVel.y);
                float forceX = body->GetMass() * velChange.x;
                float forceY = body->GetMass() * velChange.y;
                // Apply the forces to the body
                body->ApplyForceToCenter(b2Vec2(forceX, forceY), true);

            }
            b2Vec2 Get_Velocity() {
                b2Vec2 v = body->GetLinearVelocity();
                v.x *= 10;
                v.y *= -10;
                return v;
            }

            // set angular velocity
            void Set_Angular_Velocity(double angle, double vel) {
                float radians = angle * (M_PI / 180.0f) * (-1);

                // Calculate the X and Y components of the force vector
                float forceX = vel * cos(radians);
                float forceY = vel * sin(radians);

                // Apply the force to the body
                b2Vec2 forceVector(forceX, forceY);
                b2Vec2 v = { static_cast<float32>(forceX / 5), static_cast<float32>(-forceY / 5) };

                b2Vec2 desiredVel = v;

                b2Vec2 currentVel = body->GetLinearVelocity();
                b2Vec2 velChange(desiredVel.x - currentVel.x, desiredVel.y - currentVel.y);
                forceX = body->GetMass() * velChange.x;
                forceY = body->GetMass() * velChange.y;
                // Apply the forces to the body
                body->ApplyForceToCenter(b2Vec2(forceX, forceY), true);

            }
            double Get_Angular_Velocity() {
                return body->GetAngularVelocity() * 32;
            }


            // get the points of the shape
            std::vector<b2Vec2> Get_Points() {
                if (Type->c_type == CIRCLE_SHAPE) return {};
                std::vector<b2Vec2> out;
                b2PolygonShape* shape = static_cast<b2PolygonShape*> (body->GetFixtureList()->GetShape());
                
                for (int i = 0; i < shape->GetVertexCount(); i++) {
                    out.push_back(
                        {
                        static_cast<float32> (shape->GetVertex(i).x * 32),
                        static_cast<float32> (shape->GetVertex(i).y * -32)
                        });
                }
                return out;
            }
            void Set_Points(std::vector<b2Vec2> p) {
                if (Type->c_type == CIRCLE_SHAPE) return;
                b2PolygonShape* shape = static_cast<b2PolygonShape*> (body->GetFixtureList()->GetShape());
                for (int i = 0; i < p.size(); i++) {
                    b2Vec2* point = &p[i];
                    point->x /= 32;
                    point->y /= -32;
                }
                shape->Set(p.data(), p.size());
            }

            // Perform a Raycast and optionally draw it
            raycast RayCast(double dist, double angle, Obj* to, bool stop, bool Draw, SDL_Color color = ORANGE) {
                raycast out;

                b2Vec2 s = AngleAndDistance_To(Get_Center().x, Get_Center().y, angle, dist);
                if (Type->c_type == CIRCLE_SHAPE) s = AngleAndDistance_To(Get_Pos().x, Get_Pos().y, angle, dist);

                out.x = s.x;
                out.y = s.y;
                out.angle = angle;
                out.length = dist;
                _rc rc = {
                    world,
                    s.x / 32,
                    s.y / -32,
                    stop,
                    body->GetWorldCenter().x,
                    body->GetWorldCenter().y,
                    body,
                    to->body,
                };
                out.hit = rc.check();
                out.dist = dist * rc.fraction;
                out.x = rc.hitPoint.x;
                out.y = rc.hitPoint.y;
                out.normal = rc.normal;

                for (b2Body* i : rc.bodies) {
                    out.typesHit.push_back(static_cast<Obj*> (i->GetUserData())->Type);
                }

                // Display ray if requested
                if (Draw) {
                    if (rend != nullptr && cam != nullptr) {
                        SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                        SDL_RenderDrawLine(rend, Get_Pos().x - cam->x, Get_Pos().y - cam->y, rc.hitPoint.x * 32 - cam->x, rc.hitPoint.y * -32 - cam->y);

                    }
                    else {
                        std::cerr << "renderer is not defined. Use Set_Renderer() to set your renderer (Window.rend)." << "\n";
                    }
                }
                return out;
            }
            raycast RayCast(double dist, double angle, b2Body* to, bool stop, bool Draw, SDL_Color color = ORANGE) {
                raycast out;

                b2Vec2 s = AngleAndDistance_To(Get_Center().x, Get_Center().y, angle, dist);
                if (Type->c_type == CIRCLE_SHAPE) s = AngleAndDistance_To(Get_Pos().x, Get_Pos().y, angle, dist);

                out.x = s.x;
                out.y = s.y;
                out.angle = angle;
                out.length = dist;
                _rc rc = {
                    world,
                    s.x / 32,
                    s.y / -32,
                    stop,
                    body->GetWorldCenter().x,
                    body->GetWorldCenter().y,
                    body,
                    to,
                };
                out.hit = rc.check();
                out.dist = dist * rc.fraction;
                out.x = rc.hitPoint.x;
                out.y = rc.hitPoint.y;
                out.normal = rc.normal;

                for (b2Body* i : rc.bodies) {
                    out.typesHit.push_back(static_cast<Obj*> (i->GetUserData())->Type);
                }

                // Display ray if requested
                if (Draw) {
                    if (rend != nullptr && cam != nullptr) {
                        SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                        SDL_RenderDrawLine(rend, Get_Pos().x - cam->x, Get_Pos().y - cam->y, rc.hitPoint.x * 32 - cam->x, rc.hitPoint.y * -32 - cam->y);

                    }
                    else {
                        std::cerr << "renderer is not defined. Use Set_Renderer() to set your renderer (Window.rend)." << "\n";
                    }
                }
                return out;
            }
            raycast RayCast(b2Vec2 s, Obj* to, bool stop, bool Draw, SDL_Color color = ORANGE) {
                
                double angle = Angle_To(Get_Center().x, Get_Center().y, s.x, s.y);
                double length = Distance_To(Get_Center().x, Get_Center().y, s.x, s.y);
                if (Type->c_type == CIRCLE_SHAPE) length = Distance_To(Get_Pos().x, Get_Pos().y, s.x, s.y);
                return RayCast(length, angle, to, stop, Draw, color);
            }
            raycast RayCast(b2Vec2 s, b2Body* to, bool stop, bool Draw, SDL_Color color = ORANGE) {

                double angle = Angle_To(Get_Center().x, Get_Center().y, s.x, s.y);
                double length = Distance_To(Get_Center().x, Get_Center().y, s.x, s.y);
                if (Type->c_type == CIRCLE_SHAPE) length = Distance_To(Get_Pos().x, Get_Pos().y, s.x, s.y);
                return RayCast(length, angle, to, stop, Draw, color);
            }

            // Detect objects in proximity and optionally draw them
            bool proximity(Obj* to, double rad, bool draw = false, int density = 10, SDL_Color color = BLACK) {
                bool out = false;

                b2Vec2 last = AngleAndDistance_To(body->GetWorldCenter().x * 32 - cam->x, body->GetWorldCenter().y * -32 - cam->y, 0, rad);
                b2Vec2 first = last;
                for (int angle = 0; angle <= 360; angle += density) {
                    raycast r = RayCast(rad, angle, to, false, false);

                    if (r.hit) out = true;

                    b2Vec2 point = AngleAndDistance_To(body->GetWorldCenter().x * 32 - cam->x, body->GetWorldCenter().y * -32 - cam->y, angle, rad);
                    SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                    if (draw) SDL_RenderDrawLine(rend, last.x, last.y, point.x, point.y);
                    last = point;
                }
                return out;
            }
            bool proximity(b2Body* to, double rad, bool draw = false, int density = 10, SDL_Color color = BLACK) {
                bool out = false;

                b2Vec2 last = AngleAndDistance_To(body->GetWorldCenter().x * 32 - cam->x, body->GetWorldCenter().y * -32 - cam->y, 0, rad);
                b2Vec2 first = last;
                for (int angle = 0; angle <= 360; angle += density) {
                    raycast r = RayCast(rad, angle, to, false, false);

                    if (r.hit) out = true;

                    b2Vec2 point = AngleAndDistance_To(body->GetWorldCenter().x * 32 - cam->x, body->GetWorldCenter().y * -32 - cam->y, angle, rad);
                    SDL_SetRenderDrawColor(rend, color.r, color.g, color.b, color.a);
                    if (draw) SDL_RenderDrawLine(rend, last.x, last.y, point.x, point.y);
                    last = point;
                }
                return out;
            }

            b2Vec2 Set_Camera(camera* cam) {
                cam->x = Get_Center().x - cam->wW / 2;
                cam->y = Get_Center().y - cam->wH / 2;
                if (Type->c_type == CIRCLE_SHAPE) {
                    cam->x = Get_Pos().x - cam->wW / 2;
                    cam->y = Get_Pos().y - cam->wH / 2;
                }
                return { static_cast<float32> (cam->x),  static_cast<float32> (cam->y) };

            }

            bool operator==(const Obj b) {
                return (body == b.body);
            }

            b2Vec2 Get_Pos() {
                // Get position
                float32 x = body->GetPosition().x - Get_Dimensions().w / 64;
                float32 y = -body->GetPosition().y - Get_Dimensions().h / 64;
                
                x *= 32;
                y *= 32;
                return { x,y };

            }
            b2Vec2 Get_Center() {
                return { body->GetWorldCenter().x * 32, body->GetWorldCenter().y * -32 };
            }
            
            void Set_Pos(double x, double y) {
                body->SetTransform({ static_cast<float32> (x / 32 + Get_Dimensions().w / 64), static_cast<float32> (y / -32 + Get_Dimensions().h / -64) }, Get_Angle());
            }
            void Set_Pos(b2Vec2 p) {
                Set_Pos(p.x, p.y);
            }

            void Set_Center(float32 x, float32 y) {
                body->SetTransform({ static_cast<float32> (x / 32), static_cast<float32> (y / -32) }, Get_Angle());
            }
            void Set_Center(b2Vec2 p) {
                Set_Center(p.x, p.y);
            }

            void Set_Solid(bool is) {
                body->GetFixtureList()->SetSensor(!is);
            }
            bool Get_Solid() {
                return !body->GetFixtureList()->IsSensor();
            }

            collision Get_Collisions() {

                    // Get contact list (collisions)
                    b2ContactEdge* c = body->GetContactList();
                    collision col;

                    // Get collision list
                    int iterations = 0;
                    while (c) {
                        auto contact = c->contact;
                        auto fixtureB = contact->GetFixtureB();
                        Obj* b = static_cast<Obj*> (fixtureB->GetBody()->GetUserData());
                        col.Obj[b] = contact->IsTouching();
                        col.Type[b->Type] = contact->IsTouching();

                        c = c->next;
                        iterations += 1;
                    }
            
            }

            void Set_Fixed_Rotation(bool d) {
                body->SetFixedRotation(d);
            }

            // Update Object
            virtual void Update() {
                if (hasBody != false) {
                    if (em != nullptr) {
                        b2Vec2 p = { em->from->GetWorldCenter().x * 32, em->from->GetWorldCenter().y * -32 };
                        if (!emHasCollided) {
                            raycast r = RayCast(
                                p,
                                em->from,
                                false,
                                false
                            );
                            emHasCollided = (r.hit && r.dist >= 5);
                        }
                        Set_Solid(emHasCollided);
                    }
                    if (att.isAttached) {
                        Set_Pos(att.from->GetWorldCenter().x * 32 + att.offsetX, att.from->GetWorldCenter().y * -32 + att.offsetX);
                        if (att.match_angle) Set_Angle(static_cast<Obj*> (att.from->GetUserData())->Get_Angle() * (180 / M_PI) * (-1));
                        body->DestroyFixture(body->GetFixtureList());
                    }
                    if (function != nullptr) function();
                    
                    body->SetUserData(this);
                }
            }

            void Destroy() {
                if (body == nullptr) return;
                world->DestroyBody(body);
                body = nullptr;
                hasBody = false;
            }

            Obj* Emit(type* t, double force, double angle, b2Vec2 offset = { 0,0 }) {
                Obj* o = new Obj(t, body->GetWorld(), Get_Center().x + offset.x, Get_Center().y + offset.y, new emit(force, angle, body));
                o->body->SetUserData(o);
                return o;
            }
            Obj* Emit(type* t, double force, double angle, double offsetDistance = 0, double offsetAngle = 0) {
                b2Vec2 offset;
                offset = AngleAndDistance_To(0, 0, offsetAngle, offsetDistance);
                Obj* o = new Obj(t, body->GetWorld(), Get_Center().x + offset.x, Get_Center().y + offset.y, new emit(force, angle, body));
                o->body->SetUserData(o);
                return o;
            }


            attach att;
            emit* em = nullptr;

            void (*function)();

            b2World* world = nullptr;

            bool hasBody = true;

            bool GetCollisions = false;

        private:
            
            b2BodyType b_type = b2_dynamicBody;
            int ct = 0;
            camera* cam;
            double impY = 0;
            double impX = 0;
            bool emHasCollided = false;
            // Define Circle and square Fixture
            void Define_Circle(double x, double y, double rad, double dens, b2BodyType type) {
                b2BodyDef bodydef;
                bodydef.type = type;
                bodydef.position.Set(x, -y);
                b2FixtureDef fxtdef;
                body = world->CreateBody(&bodydef);
                
                b2CircleShape Dshape;
                Dshape.m_radius = Type->dimension.rad / 32;
                fxtdef.shape = &Dshape;
                fxtdef.density = dens;
                body->CreateFixture(&fxtdef);
            }
            void Define_Rect(double x, double y, double dens, b2BodyType type) {
                b2BodyDef bodydef;
                bodydef.type = type;
                bodydef.position.Set(x, -y);
                b2FixtureDef fxtdef;
                
                b2PolygonShape Dshape;
                Dshape.SetAsBox(abs(Type->dimension.w / 64), abs(Type->dimension.h / 64));
                fxtdef.shape = &Dshape;
                fxtdef.density = dens;
                
                body = world->CreateBody(&bodydef);
                body->CreateFixture(&fxtdef);
                
            }
            void Define_Polygon(double x, double y, std::vector <b2Vec2> points, double dens, b2BodyType type) {

                for (int i = 0; i < points.size(); i++) {
                    points[i].x /= 32;
                    points[i].y /= -32;
                }

                b2BodyDef bodydef;
                bodydef.type = type;
                bodydef.position.Set(x, -y);
                b2FixtureDef fxtdef;
                body = world->CreateBody(&bodydef);

                b2PolygonShape Dshape;

                Dshape.Set(points.data(), points.size());
                fxtdef.shape = &Dshape;
                fxtdef.density = dens;
                if (body == nullptr) std::cout << "the object was not defined properly and body is nullptr";
                body->CreateFixture(&fxtdef);
            }

        };

        class Window : public No_Physics::Window {
        public:

            // arguments:
            // name: the window name
            // width: the window width
            // height: the window height
            // flags: the window flags, (SHOWN, RESIZABLE, etc)
            Window(std::string _name, int _W, int _H, Uint32 flags = SHOWN) : No_Physics::Window(_name, _W, _H, flags) {
                b2Vec2 grav = { 0, -9.81 };
                world = new b2World(grav);
            
            }
            
            //  update the window, and its values
            bool Run() {
                
                // pause or update the game world
                if (!paused) world->Step(dt + 0.02, 6, 2);
                // draw bodies
                for (b2Body* i = world->GetBodyList(); i; i = i->GetNext()) {
                    Obj* o = reinterpret_cast<Obj*> (i->GetUserData());
                    if (o->body == nullptr) continue;
                    o->body->SetActive(!o->SleepWhenOutOfView && !inView(o, o->ViewBufferPixels));

                    if (!paused) {
                        o->Update();
                        o->Obj::Update();
                    }

                    if (o->sprite != "NULL" && o->body != nullptr) {
                        
                        if (o->c_type != CIRCLE_SHAPE) {
                            if (o->anim == nullptr && o->stack == nullptr) Draw_Sprite(ceil(o->Get_Pos().x) - 1, ceil(o->Get_Pos().y) - 1, o->Get_Dimensions().w + 2, o->Get_Dimensions().h + 2, o->Get_Angle() * (180 / M_PI), o->sprite, { 10,10,9,9 }, GAME_LAYER, o->DisplayOrder, o->flip);
                            else if (o->stack == nullptr) Draw_Animation(ceil(o->Get_Pos().x) - 1, ceil(o->Get_Pos().y) - 1, o->Get_Dimensions().w + 2, o->Get_Dimensions().h + 2, o->Get_Angle() * (180 / M_PI), o->anim, o->DisplayOrder, GAME_LAYER, o->flip);
                            else {
                                Draw_Sprite_Stack(ceil(o->Get_Pos().x) - 1 * 0, ceil(o->Get_Pos().y) - 1 * 0, o->Get_Dimensions().w + 2, o->Get_Dimensions().h + 2, o->Get_Angle() * (180 / M_PI), o->stack, GAME_LAYER, o->DisplayOrder, { 10,10,9,9 }, o->flip);
                            }
                        }
                        else {
                            if (o->anim == nullptr && o->stack == nullptr) Draw_Sprite(o->Get_Pos().x + o->Get_Dimensions().rad, o->Get_Pos().y + o->Get_Dimensions().rad, -o->Get_Dimensions().rad * 2, -o->Get_Dimensions().rad * 2, o->Get_Angle() * (180 / M_PI), "player.bmp");
                            else if (o->stack = nullptr) Draw_Animation(o->Get_Pos().x + o->Get_Dimensions().rad, o->Get_Pos().y + o->Get_Dimensions().rad, -o->Get_Dimensions().rad * 2, -o->Get_Dimensions().rad * 2, o->Get_Angle() * (180 / M_PI), o->anim, o->DisplayOrder, GAME_LAYER, o->flip);
                            else Draw_Sprite_Stack(o->Get_Pos().x + o->Get_Dimensions().rad, o->Get_Pos().y + o->Get_Dimensions().rad, -o->Get_Dimensions().rad * 2, -o->Get_Dimensions().rad * 2, o->Get_Angle() * (180 / M_PI), o->stack, GAME_LAYER, o->DisplayOrder, { 10,10,9,9 }, o->flip);
                        }
                    }
                
                }
                No_Physics::Window::Run();

                Update();
                return running;
            }
            virtual void Update() override {}
            
            // if the physics world is paused
            bool paused = false;

            // the physics world
            b2World* world = nullptr;

            // set the game gravity
            void Set_Gravity(float32 hor, float32 vert) {
                world->SetGravity({ hor, vert * (-1) });
            }

            // check if an object is inside the window
            bool inView(Obj* o, int viewBufferPixels = 0) {
                for (b2Vec2 i : o->Get_Points()) {
                    i.x += o->Get_Pos().x;
                    i.y += o->Get_Pos().y;
                    return (i.x > W + viewBufferPixels || i.x < 0 - viewBufferPixels || i.y > H + viewBufferPixels || i.y < 0 - viewBufferPixels);
                }
            }

            // spawn an object. arguments:
            // - the object type
            // - the object positions
            Obj* Spawn(type* t, double _x, double _y) {
                Obj* object = new Obj(t, world, _x + t->dimension.w / 2, _y + t->dimension.h / 2);
                object->Set_Center(_x + t->dimension.w, _y + t->dimension.h);
                object->body->SetUserData(object);
                object->Set_Renderer(rend, &cam);

                return object;
            }

            Obj* Emit(type* t, Obj* f, double force, double angle) {
                Obj* o = new Obj(t, world, f->Get_Center().x, f->Get_Center().y, new emit(force, angle, f->body));
                o->Set_Renderer(rend, &cam);
                o->body->SetUserData(o);
                
                return o;
            }

            Obj* Attach(Obj* from, type* t, double offsetX = 0, double offsetY = 0, bool match_angle = false) {
                Obj* object = new Obj(t, world, 0 + t->dimension.w / 2, 0 + t->dimension.h / 2);
                object->att.isAttached = true;
                object->att.offsetX = offsetX;
                object->att.offsetY = offsetY;
                object->att.match_angle = match_angle;
                object->att.from = from->body;

                object->body->SetUserData(object);
                object->Set_Renderer(rend, &cam);

                return object;
            }

            // get a Physics::Obj from a b2Body*
            Obj* Get_Obj_From_Body(b2Body* Body) {
                return reinterpret_cast<Obj*>(Body->GetUserData());
            }

        };
    }

    //------------------------
    //       functions       | 
    //------------------------

    // blend two colors together. add a factor as a third argument, and the closer it is to 0, the closer the color is to color 1, factor can only be from 0 to 1
    SDL_Color Blend_color(const SDL_Color color1, const SDL_Color color2, float factor = 0.5f, int alpha = 0) {
        // Ensure the factor is within the range [0, 1]
        factor = (factor > 1.0f ? 1.0f : (factor < 0.0f ? 0.0f : factor));

        // Calculate the blended color component-wise
        Uint8 r = static_cast<Uint8>((1.0f - factor) * color1.r + factor * color2.r);
        Uint8 g = static_cast<Uint8>((1.0f - factor) * color1.g + factor * color2.g);
        Uint8 b = static_cast<Uint8>((1.0f - factor) * color1.b + factor * color2.b);
        Uint8 a = static_cast<Uint8>((1.0f - factor) * color1.a + factor * color2.a);

        SDL_Color blendedColor = { r, g, b, (alpha == 0 ? a : alpha) };
        return blendedColor;
    }
    SDL_Texture* Load_Sprite(SDL_Renderer* rend, std::string file) {
        SDL_Texture* spriteTexture = SDL_CreateTextureFromSurface(rend, SDL_LoadBMP(file.c_str()));
        if (!spriteTexture) {
            SDL_Log("Unable to load sprite texture: %s", SDL_GetError());
        }
        return spriteTexture;
    }

    
    // play sound
    void Play_Sound(std::string file) {
        if (Get_OS() == WINDOWS) {
            // Build the mciSendString command to open and play the sound file
            std::string command = "open \"" + file + "\" type mpegvideo alias mySound";
            mciSendStringA(command.c_str(), NULL, 0, NULL);

            // Play the sound
            mciSendStringA("play mySound", NULL, 0, NULL);
        }
    }

    //---------------------
    //         MATH       |
    //---------------------
    
    float Angle_To(int p1x, int p1y, int p2x, int p2y)
    {
        int deltaY = p2y - p1y;
        int deltaX = p2x - p1x;

        float angleInDegrees = atan2(deltaY, deltaX) * 180 / M_PI;


        return angleInDegrees;
    }
    float Angle_To(b2Vec2 p1, b2Vec2 p2)
    {
        int deltaY = p2.y - p1.y;
        int deltaX = p2.x - p1.x;

        float angleInDegrees = atan2(deltaY, deltaX) * 180 / M_PI;


        return angleInDegrees;
    }

    double Distance_To(int x, int y, int x1, int y1) {
        int a = x1 - x;
        int b = y1 - y;
        int c = sqrt(a * a + b * b);
        return abs(c);
    }
    double Distance_To(b2Vec2 p1, b2Vec2 p2) {
        int a = p2.x - p1.x;
        int b = p2.y - p1.y;
        int c = sqrt(a * a + b * b);
        return abs(c);
    }
    b2Vec2 AngleAndDistance_To(int x, int y, double angle, double distance) {
        // Convert angle from degrees to radians
        double radians = angle * M_PI / 180.0;

        // Calculate the destination coordinates as doubles
        double dx = distance * cos(radians);
        double dy = distance * sin(radians);

        return { static_cast<float32>(dx + x), static_cast<float32>(dy + y) };
    }
    
    int Random(int num1, int num2) {
        std::random_device dev;
        std::default_random_engine gen{dev()};
        std::uniform_int_distribution<int> dis{num1, num2};
        return dis(gen);
    }

    SDL_Color Random_Color() {
        SDL_Color color = { Random(0,255),Random(0,255),Random(0,255),255 };
        return color;
    }

    //----------------------
    //      save/load      |
    //----------------------

    bool Save(std::string content, const std::string& filename) {
        std::ofstream file(filename);
        if (!file.is_open()) {
            std::cerr << "Error: Unable to open the file for writing." << std::endl;
            return false;
        }

        file << content; // Write content to the file
        file.close();
        return true;
    }
    std::string Load(const std::string& filename) {
        std::string out;
        std::ifstream file(filename);
        if (!file.is_open()) {
            std::cerr << "Error: Unable to open the file for reading." << std::endl;
            return "NULL";
        }

        std::string line;

        while (std::getline(file, line)) {
            out += line + "\n"; // Read each line and append it to the content
        }

        file.close();
        return out;
    }
    bool Clear_File(const std::string& filename) {
        std::ofstream file(filename, std::ios::trunc); // Open the file in truncation mode

        if (!file.is_open()) {
            std::cerr << "Error: Unable to open the file for clearing." << std::endl;
            return false;
        }

        file.close();
        return true;
    }

    //---------------------
    //        other       |
    //---------------------

    double cast(double val, double min, double max) {
        return (val >= max ? max : val <= min ? min : val);
    }

    std::vector<std::vector<SDL_Color>> bmp_To_Vector(std::string Path) {
        SDL_Surface* surface = SDL_LoadBMP(Path.c_str());
        if (!surface) {
            // Handle error
            return {};
        }

        std::vector<std::vector<SDL_Color>> pixelData(surface->h, std::vector<SDL_Color>(surface->w));

        for (int y = 0; y < surface->h; ++y) {
            for (int x = 0; x < surface->w; ++x) {
                Uint32 pixel = *((Uint32*)surface->pixels + y * surface->w + x);
                Uint8 r, g, b, a;
                SDL_GetRGBA(pixel, surface->format, &r, &g, &b, &a);
                pixelData[y][x] = { r, g, b, a };
            }
        }

        SDL_FreeSurface(surface);
        return pixelData;
    }
    char* vector_To_Bmp(const std::vector<std::vector<SDL_Color>>& pixelData, std::string location, std::string name) {
        int width = pixelData[0].size();
        int height = pixelData.size();
        SDL_Surface* surface = SDL_CreateRGBSurface(0, width, height, 32, 0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF);
        if (!surface) {
            SDL_Log("Unable to create surface: %s", SDL_GetError());
            return nullptr;
        }

        for (int y = 0; y < height; ++y) {
            for (int x = 0; x < width; ++x) {
                SDL_Color color = pixelData[y][x];
                Uint32 pixelValue = SDL_MapRGBA(surface->format, color.r, color.g, color.b, color.a);
                *((Uint32*)surface->pixels + y * width + x) = pixelValue;
            }
        }

        std::string fileName = location + name + ".bmp";

        if (SDL_SaveBMP(surface, fileName.c_str()) != 0) {
            SDL_Log("Unable to save BMP: %s", SDL_GetError());
            SDL_FreeSurface(surface);
            return nullptr;
        }

        SDL_FreeSurface(surface);

        // Convert the file name to char* and return
        char* charFileName = new char[fileName.size() + 1];
        strcpy_s(charFileName, fileName.size() + 1, fileName.c_str());
        return charFileName;
    }

    void debug_double(std::string valname, double value, std::string additional = "") {
        std::cout << "\n" + valname + ": ";
        std::cout << value;
        std::cout << additional;
    }
    void debug_string(std::string valname, std::string value, std::string additional = "") {
        std::cout << "\n" + valname + ": ";
        std::cout << value;
        std::cout << additional;
    }
    void debug_bool(std::string valname, bool value, std::string additional = "") {
        std::cout << "\n" + valname + ": ";
        std::cout << (value == true ? "true" : "false");
        std::cout << additional;
    }
    void debug_intV(std::string valname, std::vector<int> list, std::string additional = "") {
        std::cout << "\n" + valname + ": " + "{ ";
        for (int i = 0; i < list.size(); i++) {
            std::cout << list[i] << (i == list.size() - 1 ? " " : ", ");
        }
        std::cout << "}" + additional;
    }
    void debug_floatV(std::string valname, std::vector<float> list, std::string additional = "") {
        std::cout << "\n" + valname + ": " + "{ ";
        for (int i = 0; i < list.size(); i++) {
            std::cout << list[i] << (i == list.size() - 1 ? " " : ", ");
        }
        std::cout << "}" + additional;
    }
    void debug_doubleV(std::string valname, std::vector < double > list, std::string additional = "") {
        std::cout << "\n" + valname + ": " + "{ ";
        for (int i = 0; i < list.size(); i++) {
            std::cout << list[i] << (i == list.size() - 1 ? " " : ", ");
        }
        std::cout << "}" + additional;
    }
    void debug_boolV(std::string valname, std::vector<bool> list, std::string additional = "") {
        std::cout << "\n" + valname + ": " + "{ ";
        for (int i = 0; i < list.size(); i++) {
            std::cout << (list[i] == true ? "true" : "false") << (i == list.size() - 1 ? " " : ", ");
        }
        std::cout << "}" + additional;
    }
    void debug_stringV(std::string valname, std::vector<std::string> list, std::string additional = "") {
        std::cout << "\n" + valname + ": " + "{ ";
        for (int i = 0; i < list.size(); i++) {
            std::cout << list[i] << (i == list.size() - 1 ? " " : ", ");
        }
        std::cout << "}" + additional;
    }
}
